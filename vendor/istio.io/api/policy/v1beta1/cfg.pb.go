// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: policy/v1beta1/cfg.proto

package v1beta1

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	io "io"
	_ "istio.io/gogo-genproto/googleapis/google/api"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Header operation type.
type Rule_HeaderOperationTemplate_Operation int32

const (
	// Replace a header by name.
	REPLACE Rule_HeaderOperationTemplate_Operation = 0
	// Remove a header by name. Values are ignored.
	REMOVE Rule_HeaderOperationTemplate_Operation = 1
	// Append values to the existing header values.
	APPEND Rule_HeaderOperationTemplate_Operation = 2
)

var Rule_HeaderOperationTemplate_Operation_name = map[int32]string{
	0: "REPLACE",
	1: "REMOVE",
	2: "APPEND",
}

var Rule_HeaderOperationTemplate_Operation_value = map[string]int32{
	"REPLACE": 0,
	"REMOVE":  1,
	"APPEND":  2,
}

func (Rule_HeaderOperationTemplate_Operation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{1, 0, 0}
}

// Fraction percentages support several fixed denominator values.
type FractionalPercent_DenominatorType int32

const (
	// 100.
	//
	// **Example**: 1/100 = 1%.
	HUNDRED FractionalPercent_DenominatorType = 0
	// 10,000.
	//
	// **Example**: 1/10000 = 0.01%.
	TEN_THOUSAND FractionalPercent_DenominatorType = 1
)

var FractionalPercent_DenominatorType_name = map[int32]string{
	0: "HUNDRED",
	1: "TEN_THOUSAND",
}

var FractionalPercent_DenominatorType_value = map[string]int32{
	"HUNDRED":      0,
	"TEN_THOUSAND": 1,
}

func (FractionalPercent_DenominatorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{9, 0}
}

// AuthHeader specifies how to pass access token with authorization header.
type Tls_AuthHeader int32

const (
	// Access token is passed in authorization header as what it is
	// (authorization: some-token).
	PLAIN Tls_AuthHeader = 0
	// Access token is passed to adapter as bearer token (i.e. authorization:
	// bearer some-token).
	BEARER Tls_AuthHeader = 1
)

var Tls_AuthHeader_name = map[int32]string{
	0: "PLAIN",
	1: "BEARER",
}

var Tls_AuthHeader_value = map[string]int32{
	"PLAIN":  0,
	"BEARER": 1,
}

func (Tls_AuthHeader) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{11, 0}
}

// AttributeManifest describes a set of Attributes produced by some component
// of an Istio deployment.
//
// <!-- go code generation tags
// +kubetype-gen
// +kubetype-gen:groupVersion=config.istio.io/v1alpha2
// +genclient
// +k8s:deepcopy-gen=true
// -->
type AttributeManifest struct {
	// The revision of this document. Assigned by server.
	Revision string `protobuf:"bytes,1,opt,name=revision,proto3" json:"revision,omitempty"`
	// Name of the component producing these attributes. This can be
	// the proxy (with the canonical name `istio-proxy`) or the name of an
	// `attributes` kind adapter in Mixer.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The set of attributes this Istio component will be responsible for producing at runtime.
	// We map from attribute name to the attribute's specification. The name of an attribute,
	// which is how attributes are referred to in aspect configuration, must conform to:
	//
	//     Name = IDENT { SEPARATOR IDENT };
	//
	// Where `IDENT` must match the regular expression `[a-z][a-z0-9]+` and `SEPARATOR` must
	// match the regular expression `[\.-]`.
	//
	// Attribute names must be unique within a single Istio deployment. The set of canonical
	// attributes are described at [here](https://istio.io/docs/reference/config/policy-and-telemetry/attribute-vocabulary/).
	// Attributes not in that list should be named with a component-specific suffix such as
	// `request.count-my.component`.
	Attributes map[string]*AttributeManifest_AttributeInfo `protobuf:"bytes,3,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AttributeManifest) Reset()      { *m = AttributeManifest{} }
func (*AttributeManifest) ProtoMessage() {}
func (*AttributeManifest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{0}
}
func (m *AttributeManifest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttributeManifest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttributeManifest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttributeManifest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttributeManifest.Merge(m, src)
}
func (m *AttributeManifest) XXX_Size() int {
	return m.Size()
}
func (m *AttributeManifest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttributeManifest.DiscardUnknown(m)
}

var xxx_messageInfo_AttributeManifest proto.InternalMessageInfo

func (m *AttributeManifest) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

func (m *AttributeManifest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AttributeManifest) GetAttributes() map[string]*AttributeManifest_AttributeInfo {
	if m != nil {
		return m.Attributes
	}
	return nil
}

// AttributeInfo describes the schema of an Istio `Attribute`.
//
// # Istio Attributes
//
// Istio uses `attributes` to describe runtime activities of Istio services.
// An Istio attribute carries a specific piece of information about an activity,
// such as the error code of an API request, the latency of an API request, or the
// original IP address of a TCP connection. The attributes are often generated
// and consumed by different services. For example, a frontend service can
// generate an authenticated user attribute and pass it to a backend service for
// access control purpose.
//
// To simplify the system and improve developer experience, Istio uses
// shared attribute definitions across all components. For example, the same
// authenticated user attribute will be used for logging, monitoring, analytics,
// billing, access control, auditing. Many Istio components provide their
// functionality by collecting, generating, and operating on attributes.
// For example, the proxy collects the error code attribute, and the logging
// stores it into a log.
//
// # Design
//
// Each Istio attribute must conform to an `AttributeInfo` in an
// `AttributeManifest` in the current Istio deployment at runtime. An
// [`AttributeInfo`][istio.policy.v1beta1] is used to define an attribute's
// metadata: the type of its value and a detailed description that explains
// the semantics of the attribute type. Each attribute's name is globally unique;
// in other words an attribute name can only appear once across all manifests.
//
// The runtime presentation of an attribute is intentionally left out of this
// specification, because passing attribute using JSON, XML, or Protocol Buffers
// does not change the semantics of the attribute. Different implementations
// can choose different representations based on their needs.
//
// # HTTP Mapping
//
// Because many systems already have REST APIs, it makes sense to define a
// standard HTTP mapping for Istio attributes that are compatible with typical
// REST APIs. The design is to map one attribute to one HTTP header, the
// attribute name and value becomes the HTTP header name and value. The actual
// encoding scheme will be decided later.
type AttributeManifest_AttributeInfo struct {
	// A human-readable description of the attribute's purpose.
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// The type of data carried by this attribute.
	ValueType ValueType `protobuf:"varint,2,opt,name=value_type,json=valueType,proto3,enum=istio.policy.v1beta1.ValueType" json:"value_type,omitempty"`
}

func (m *AttributeManifest_AttributeInfo) Reset()      { *m = AttributeManifest_AttributeInfo{} }
func (*AttributeManifest_AttributeInfo) ProtoMessage() {}
func (*AttributeManifest_AttributeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{0, 0}
}
func (m *AttributeManifest_AttributeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttributeManifest_AttributeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttributeManifest_AttributeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttributeManifest_AttributeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttributeManifest_AttributeInfo.Merge(m, src)
}
func (m *AttributeManifest_AttributeInfo) XXX_Size() int {
	return m.Size()
}
func (m *AttributeManifest_AttributeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AttributeManifest_AttributeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AttributeManifest_AttributeInfo proto.InternalMessageInfo

func (m *AttributeManifest_AttributeInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *AttributeManifest_AttributeInfo) GetValueType() ValueType {
	if m != nil {
		return m.ValueType
	}
	return VALUE_TYPE_UNSPECIFIED
}

// A Rule is a selector and a set of intentions to be executed when the
// selector is `true`
//
// The following example instructs Mixer to invoke `prometheus-handler` handler for all services and pass it the
// instance constructed using the 'RequestCountByService' instance.
//
// ```yaml
// - match: match(destination.service.host, "*")
//   actions:
//   - handler: prometheus-handler
//     instances:
//     - RequestCountByService
// ```
//
// <!-- go code generation tags
// +kubetype-gen
// +kubetype-gen:groupVersion=config.istio.io/v1alpha2
// +genclient
// +k8s:deepcopy-gen=true
// -->
type Rule struct {
	// Match is an attribute based predicate. When Mixer receives a
	// request it evaluates the match expression and executes all the associated `actions`
	// if the match evaluates to true.
	//
	// A few example match:
	//
	// * an empty match evaluates to `true`
	// * `true`, a boolean literal; a rule with this match will always be executed
	// * `match(destination.service.host, "ratings.*")` selects any request targeting a service whose
	// name starts with "ratings"
	// * `attr1 == "20" && attr2 == "30"` logical AND, OR, and NOT are also available
	Match string `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
	// The actions that will be executed when match evaluates to `true`.
	Actions []*Action `protobuf:"bytes,2,rep,name=actions,proto3" json:"actions,omitempty"`
	// Templatized operations on the request headers using values produced by the
	// rule actions. Require the check action result to be OK.
	RequestHeaderOperations []*Rule_HeaderOperationTemplate `protobuf:"bytes,3,rep,name=request_header_operations,json=requestHeaderOperations,proto3" json:"request_header_operations,omitempty"`
	// Templatized operations on the response headers using values produced by the
	// rule actions. Require the check action result to be OK.
	ResponseHeaderOperations []*Rule_HeaderOperationTemplate `protobuf:"bytes,4,rep,name=response_header_operations,json=responseHeaderOperations,proto3" json:"response_header_operations,omitempty"`
	// $hide_from_docs
	// Provides the ability to add a sampling configuration for Mixer rules. This sampling
	// will limit the scenarios in which the `actions` of the rule are executed. The sampling will
	// only take place after a `match` predicate has evaluated to true.
	//
	// Default behavior is no sampling (the `actions` are executed for all requests).
	Sampling *Sampling `protobuf:"bytes,5,opt,name=sampling,proto3" json:"sampling,omitempty"`
}

func (m *Rule) Reset()      { *m = Rule{} }
func (*Rule) ProtoMessage() {}
func (*Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{1}
}
func (m *Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rule.Merge(m, src)
}
func (m *Rule) XXX_Size() int {
	return m.Size()
}
func (m *Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_Rule proto.InternalMessageInfo

func (m *Rule) GetMatch() string {
	if m != nil {
		return m.Match
	}
	return ""
}

func (m *Rule) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *Rule) GetRequestHeaderOperations() []*Rule_HeaderOperationTemplate {
	if m != nil {
		return m.RequestHeaderOperations
	}
	return nil
}

func (m *Rule) GetResponseHeaderOperations() []*Rule_HeaderOperationTemplate {
	if m != nil {
		return m.ResponseHeaderOperations
	}
	return nil
}

func (m *Rule) GetSampling() *Sampling {
	if m != nil {
		return m.Sampling
	}
	return nil
}

// A template for an HTTP header manipulation. Values in the template are expressions
// that may reference action outputs by name. For example, if an action `x` produces an output
// with a field `f`, then the header value expressions may use attribute `x.output.f` to reference
// the field value:
//
// ```yaml
// request_header_operations:
// - name: x-istio-header
//   values:
//   - x.output.f
// ```
//
// If the header value expression evaluates to an empty string, and the operation is to either replace
// or append a header, then the operation is not applied. This permits conditional behavior on behalf of the
// adapter to optionally modify the headers.
type Rule_HeaderOperationTemplate struct {
	// Header name literal value.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Header value expressions.
	Values []string `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
	// Header operation type. Default operation is to replace the value of the header by name.
	Operation Rule_HeaderOperationTemplate_Operation `protobuf:"varint,3,opt,name=operation,proto3,enum=istio.policy.v1beta1.Rule_HeaderOperationTemplate_Operation" json:"operation,omitempty"`
}

func (m *Rule_HeaderOperationTemplate) Reset()      { *m = Rule_HeaderOperationTemplate{} }
func (*Rule_HeaderOperationTemplate) ProtoMessage() {}
func (*Rule_HeaderOperationTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{1, 0}
}
func (m *Rule_HeaderOperationTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rule_HeaderOperationTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rule_HeaderOperationTemplate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rule_HeaderOperationTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rule_HeaderOperationTemplate.Merge(m, src)
}
func (m *Rule_HeaderOperationTemplate) XXX_Size() int {
	return m.Size()
}
func (m *Rule_HeaderOperationTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_Rule_HeaderOperationTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_Rule_HeaderOperationTemplate proto.InternalMessageInfo

func (m *Rule_HeaderOperationTemplate) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Rule_HeaderOperationTemplate) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *Rule_HeaderOperationTemplate) GetOperation() Rule_HeaderOperationTemplate_Operation {
	if m != nil {
		return m.Operation
	}
	return REPLACE
}

// Action describes which [Handler][istio.policy.v1beta1.Handler] to invoke and what data to pass to it for processing.
//
// The following example instructs Mixer to invoke 'prometheus-handler' handler and pass it the object
// constructed using the instance 'RequestCountByService'.
//
// ```yaml
//   handler: prometheus-handler
//   instances:
//   - RequestCountByService
// ```
type Action struct {
	// Fully qualified name of the handler to invoke.
	// Must match the `name` of a [Handler][istio.policy.v1beta1.Handler.name].
	Handler string `protobuf:"bytes,2,opt,name=handler,proto3" json:"handler,omitempty"`
	// Each value must match the fully qualified name of the
	// [Instance][istio.policy.v1beta1.Instance.name]s.
	// Referenced instances are evaluated by resolving the attributes/literals for all the fields.
	// The constructed objects are then passed to the `handler` referenced within this action.
	Instances []string `protobuf:"bytes,3,rep,name=instances,proto3" json:"instances,omitempty"`
	// A handle to refer to the results of the action.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Action) Reset()      { *m = Action{} }
func (*Action) ProtoMessage() {}
func (*Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{2}
}
func (m *Action) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Action.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action.Merge(m, src)
}
func (m *Action) XXX_Size() int {
	return m.Size()
}
func (m *Action) XXX_DiscardUnknown() {
	xxx_messageInfo_Action.DiscardUnknown(m)
}

var xxx_messageInfo_Action proto.InternalMessageInfo

func (m *Action) GetHandler() string {
	if m != nil {
		return m.Handler
	}
	return ""
}

func (m *Action) GetInstances() []string {
	if m != nil {
		return m.Instances
	}
	return nil
}

func (m *Action) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// An Instance tells Mixer how to create instances for particular template.
//
// Instance is defined by the operator. Instance is defined relative to a known
// template. Their purpose is to tell Mixer how to use attributes or literals to produce
// instances of the specified template at runtime.
//
// The following example instructs Mixer to construct an instance associated with template
// 'istio.mixer.adapter.metric.Metric'. It provides a mapping from the template's fields to expressions.
// Instances produced with this instance can be referenced by [Actions][istio.policy.v1beta1.Action] using name
// 'RequestCountByService'
//
// ```yaml
// - name: RequestCountByService
//   template: istio.mixer.adapter.metric.Metric
//   params:
//     value: 1
//     dimensions:
//       source: source.name
//       destination_ip: destination.ip
// ```
//
// <!-- go code generation tags
// +kubetype-gen
// +kubetype-gen:groupVersion=config.istio.io/v1alpha2
// +genclient
// +k8s:deepcopy-gen=true
// -->
type Instance struct {
	// The name of this instance
	//
	// Must be unique amongst other Instances in scope. Used by [Action][istio.policy.v1beta1.Action] to refer
	// to an instance produced by this instance.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The name of the compiled in template this instance creates instances for. For referencing non compiled-in
	// templates, use the `template` field instead.
	//
	// The value must match the name of the available template Mixer is built with.
	CompiledTemplate string `protobuf:"bytes,67794676,opt,name=compiled_template,json=compiledTemplate,proto3" json:"compiled_template,omitempty"`
	// The name of the template this instance creates instances for. For referencing compiled-in
	// templates, use the `compiled_template` field instead.
	//
	// The value must match the name of the available template in scope.
	Template string `protobuf:"bytes,2,opt,name=template,proto3" json:"template,omitempty"`
	// Depends on referenced template. Struct representation of a
	// proto defined by the template; this varies depending on the value of field `template`.
	Params *types.Struct `protobuf:"bytes,3,opt,name=params,proto3" json:"params,omitempty"`
	// Defines attribute bindings to map the output of attribute-producing adapters back into
	// the attribute space. The variable `output` refers to the output template instance produced
	// by the adapter.
	// The following example derives `source.namespace` from `source.uid` in the context of Kubernetes:
	// ```yaml
	// params:
	//   # Pass the required attribute data to the adapter
	//   source_uid: source.uid | ""
	// attribute_bindings:
	//   # Fill the new attributes from the adapter produced output
	//   source.namespace: output.source_namespace
	// ```
	AttributeBindings map[string]string `protobuf:"bytes,4,rep,name=attribute_bindings,json=attributeBindings,proto3" json:"attribute_bindings,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Instance) Reset()      { *m = Instance{} }
func (*Instance) ProtoMessage() {}
func (*Instance) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{3}
}
func (m *Instance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Instance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Instance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Instance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Instance.Merge(m, src)
}
func (m *Instance) XXX_Size() int {
	return m.Size()
}
func (m *Instance) XXX_DiscardUnknown() {
	xxx_messageInfo_Instance.DiscardUnknown(m)
}

var xxx_messageInfo_Instance proto.InternalMessageInfo

func (m *Instance) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Instance) GetCompiledTemplate() string {
	if m != nil {
		return m.CompiledTemplate
	}
	return ""
}

func (m *Instance) GetTemplate() string {
	if m != nil {
		return m.Template
	}
	return ""
}

func (m *Instance) GetParams() *types.Struct {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Instance) GetAttributeBindings() map[string]string {
	if m != nil {
		return m.AttributeBindings
	}
	return nil
}

// Handler allows the operator to configure a specific adapter implementation.
// Each adapter implementation defines its own `params` proto.
//
// In the following example we define a `metrics` handler for the `prometheus` adapter.
// The example is in the form of a Kubernetes resource:
// * The `metadata.name` is the name of the handler
// * The `kind` refers to the adapter name
// * The `spec` block represents adapter-specific configuration as well as the connection information
//
// ```yaml
// # Sample-1: No connection specified (for compiled in adapters)
// # Note: if connection information is not specified, the adapter configuration is directly inside
// # `spec` block. This is going to be DEPRECATED in favor of Sample-2
// apiVersion: "config.istio.io/v1alpha2"
// kind: handler
// metadata:
//   name: requestcount
//   namespace: istio-system
// spec:
//   compiledAdapter: prometheus
//   params:
//     metrics:
//     - name: request_count
//       instance_name: requestcount.metric.istio-system
//       kind: COUNTER
//       label_names:
//       - source_service
//       - source_version
//       - destination_service
//       - destination_version
// ---
// # Sample-2: With connection information (for out-of-process adapters)
// # Note: Unlike sample-1, the adapter configuration is parallel to `connection` and is nested inside `param` block.
// apiVersion: "config.istio.io/v1alpha2"
// kind: handler
// metadata:
//   name: requestcount
//   namespace: istio-system
// spec:
//   compiledAdapter: prometheus
//   params:
//     param:
//       metrics:
//       - name: request_count
//         instance_name: requestcount.metric.istio-system
//         kind: COUNTER
//         label_names:
//         - source_service
//         - source_version
//         - destination_service
//         - destination_version
//     connection:
//       address: localhost:8090
// ---
// ```
//
// <!-- go code generation tags
// +kubetype-gen
// +kubetype-gen:groupVersion=config.istio.io/v1alpha2
// +genclient
// +k8s:deepcopy-gen=true
// -->
type Handler struct {
	// Must be unique in the entire Mixer configuration. Used by [Actions][istio.policy.v1beta1.Action.handler]
	// to refer to this handler.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The name of the compiled in adapter this handler instantiates. For referencing non compiled-in
	// adapters, use the `adapter` field instead.
	//
	// The value must match the name of the available adapter Mixer is built with. An adapter's name is typically a
	// constant in its code.
	CompiledAdapter string `protobuf:"bytes,67794676,opt,name=compiled_adapter,json=compiledAdapter,proto3" json:"compiled_adapter,omitempty"`
	// The name of a specific adapter implementation. For referencing compiled-in
	// adapters, use the `compiled_adapter` field instead.
	//
	// An adapter's implementation name is typically a constant in its code.
	Adapter string `protobuf:"bytes,2,opt,name=adapter,proto3" json:"adapter,omitempty"`
	// Depends on adapter implementation. Struct representation of a
	// proto defined by the adapter implementation; this varies depending on the value of field `adapter`.
	Params *types.Struct `protobuf:"bytes,3,opt,name=params,proto3" json:"params,omitempty"`
	// Information on how to connect to the out-of-process adapter.
	// This is used if the adapter is not compiled into Mixer binary and is running as a separate process.
	Connection *Connection `protobuf:"bytes,4,opt,name=connection,proto3" json:"connection,omitempty"`
}

func (m *Handler) Reset()      { *m = Handler{} }
func (*Handler) ProtoMessage() {}
func (*Handler) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{4}
}
func (m *Handler) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Handler) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Handler.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Handler) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Handler.Merge(m, src)
}
func (m *Handler) XXX_Size() int {
	return m.Size()
}
func (m *Handler) XXX_DiscardUnknown() {
	xxx_messageInfo_Handler.DiscardUnknown(m)
}

var xxx_messageInfo_Handler proto.InternalMessageInfo

func (m *Handler) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Handler) GetCompiledAdapter() string {
	if m != nil {
		return m.CompiledAdapter
	}
	return ""
}

func (m *Handler) GetAdapter() string {
	if m != nil {
		return m.Adapter
	}
	return ""
}

func (m *Handler) GetParams() *types.Struct {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Handler) GetConnection() *Connection {
	if m != nil {
		return m.Connection
	}
	return nil
}

// Connection allows the operator to specify the endpoint for out-of-process infrastructure backend.
// Connection is part of the handler custom resource and is specified alongside adapter specific configuration.
type Connection struct {
	// The address of the backend.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// Timeout for remote calls to the backend.
	Timeout *time.Duration `protobuf:"bytes,3,opt,name=timeout,proto3,stdduration" json:"timeout,omitempty"`
	// Auth config for the connection to the backend. If omitted, plain text will
	// be used.
	Authentication *Authentication `protobuf:"bytes,4,opt,name=authentication,proto3" json:"authentication,omitempty"`
}

func (m *Connection) Reset()      { *m = Connection{} }
func (*Connection) ProtoMessage() {}
func (*Connection) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{5}
}
func (m *Connection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Connection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Connection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Connection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connection.Merge(m, src)
}
func (m *Connection) XXX_Size() int {
	return m.Size()
}
func (m *Connection) XXX_DiscardUnknown() {
	xxx_messageInfo_Connection.DiscardUnknown(m)
}

var xxx_messageInfo_Connection proto.InternalMessageInfo

func (m *Connection) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Connection) GetTimeout() *time.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *Connection) GetAuthentication() *Authentication {
	if m != nil {
		return m.Authentication
	}
	return nil
}

// $hide_from_docs
// Sampling provides configuration of sampling strategies for Rule actions.
// Multiple sampling strategies are supported. When multiple strategies are configured,
// a request must be selected by all configured sampling strategies.
type Sampling struct {
	// Provides filtering of actions based on random selection per request.
	Random *RandomSampling `protobuf:"bytes,1,opt,name=random,proto3" json:"random,omitempty"`
	// Provides filtering of actions based on number of requests observed within
	// a configured time window.
	RateLimit *RateLimitSampling `protobuf:"bytes,2,opt,name=rate_limit,json=rateLimit,proto3" json:"rate_limit,omitempty"`
}

func (m *Sampling) Reset()      { *m = Sampling{} }
func (*Sampling) ProtoMessage() {}
func (*Sampling) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{6}
}
func (m *Sampling) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sampling) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sampling.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sampling) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sampling.Merge(m, src)
}
func (m *Sampling) XXX_Size() int {
	return m.Size()
}
func (m *Sampling) XXX_DiscardUnknown() {
	xxx_messageInfo_Sampling.DiscardUnknown(m)
}

var xxx_messageInfo_Sampling proto.InternalMessageInfo

func (m *Sampling) GetRandom() *RandomSampling {
	if m != nil {
		return m.Random
	}
	return nil
}

func (m *Sampling) GetRateLimit() *RateLimitSampling {
	if m != nil {
		return m.RateLimit
	}
	return nil
}

// $hide_from_docs
// RandomSampling will filter based on the comparison of a randomly-generated value
// against the threshold provided.
//
// Example: To restrict the execution of Rule actions to only 12.5% of requests, the
// `sampling_rate` would be set `12.5`.
//
// This sampling configuration is meant to closely match the access log RuntimeFilter configuration
// [supported by Envoy](https://github.com/envoyproxy/data-plane-api/blob/master/envoy/config/filter/accesslog/v2/accesslog.proto#L113)
type RandomSampling struct {
	// Specifies an attribute expression to use to override the numerator in the `percent_sampled` field.
	// If this value is set, but no value is found OR if that value is not a numeric value, then
	// the derived sampling rate will be 0 (meaning no `Action`s are executed for a `Rule`).
	AttributeExpression string `protobuf:"bytes,1,opt,name=attribute_expression,json=attributeExpression,proto3" json:"attribute_expression,omitempty"`
	// The default sampling rate, expressed as a percentage. Defaults to 0% with a denominator
	// of 100.
	PercentSampled *FractionalPercent `protobuf:"bytes,2,opt,name=percent_sampled,json=percentSampled,proto3" json:"percent_sampled,omitempty"`
	// By default sampling will be based on the value of the request header `x-request-id`.
	// This behavior will cause consistent sampling across `Rule`s and for the full trace of a
	// request through a mesh (across hosts). If that value is not present and/or
	// `use_independent_randomness` is set to true, the sampling will be done based on the value of
	// attribute specified in `attribute_epxression`. If that attribute does not exist, the system
	// will behave as if the sampling rate was 0 (meaning no `Action`s are executed for a `Rule`).
	UseIndependentRandomness bool `protobuf:"varint,3,opt,name=use_independent_randomness,json=useIndependentRandomness,proto3" json:"use_independent_randomness,omitempty"`
}

func (m *RandomSampling) Reset()      { *m = RandomSampling{} }
func (*RandomSampling) ProtoMessage() {}
func (*RandomSampling) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{7}
}
func (m *RandomSampling) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RandomSampling) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RandomSampling.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RandomSampling) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RandomSampling.Merge(m, src)
}
func (m *RandomSampling) XXX_Size() int {
	return m.Size()
}
func (m *RandomSampling) XXX_DiscardUnknown() {
	xxx_messageInfo_RandomSampling.DiscardUnknown(m)
}

var xxx_messageInfo_RandomSampling proto.InternalMessageInfo

func (m *RandomSampling) GetAttributeExpression() string {
	if m != nil {
		return m.AttributeExpression
	}
	return ""
}

func (m *RandomSampling) GetPercentSampled() *FractionalPercent {
	if m != nil {
		return m.PercentSampled
	}
	return nil
}

func (m *RandomSampling) GetUseIndependentRandomness() bool {
	if m != nil {
		return m.UseIndependentRandomness
	}
	return false
}

// $hide_from_docs
// RateLimitSampling provides the ability to limit the number of Rule action executions that
// occur over a period of time.
type RateLimitSampling struct {
	// Window in which to enforce the sampling rate.
	SamplingDuration time.Duration `protobuf:"bytes,1,opt,name=sampling_duration,json=samplingDuration,proto3,stdduration" json:"sampling_duration"`
	// Number of entries to allow during the `sampling_duration` before sampling is enforced.
	MaxUnsampledEntries int64 `protobuf:"varint,2,opt,name=max_unsampled_entries,json=maxUnsampledEntries,proto3" json:"max_unsampled_entries,omitempty"`
	// The rate at which to sample entries once the unsampled limit has been reached. Sampling will be enforced
	// as 1 per every `sampling_rate` entries allowed.
	SamplingRate int64 `protobuf:"varint,3,opt,name=sampling_rate,json=samplingRate,proto3" json:"sampling_rate,omitempty"`
}

func (m *RateLimitSampling) Reset()      { *m = RateLimitSampling{} }
func (*RateLimitSampling) ProtoMessage() {}
func (*RateLimitSampling) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{8}
}
func (m *RateLimitSampling) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimitSampling) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimitSampling.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimitSampling) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitSampling.Merge(m, src)
}
func (m *RateLimitSampling) XXX_Size() int {
	return m.Size()
}
func (m *RateLimitSampling) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitSampling.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitSampling proto.InternalMessageInfo

func (m *RateLimitSampling) GetSamplingDuration() time.Duration {
	if m != nil {
		return m.SamplingDuration
	}
	return 0
}

func (m *RateLimitSampling) GetMaxUnsampledEntries() int64 {
	if m != nil {
		return m.MaxUnsampledEntries
	}
	return 0
}

func (m *RateLimitSampling) GetSamplingRate() int64 {
	if m != nil {
		return m.SamplingRate
	}
	return 0
}

// $hide_from_docs
// A fractional percentage is used in cases in which for performance reasons performing floating
// point to integer conversions during randomness calculations is undesirable. The message includes
// both a numerator and denominator that together determine the final fractional value.
//
// * **Example**: 1/100 = 1%.
// * **Example**: 3/10000 = 0.03%.
type FractionalPercent struct {
	// Specifies the numerator. Defaults to 0.
	Numerator uint32 `protobuf:"varint,1,opt,name=numerator,proto3" json:"numerator,omitempty"`
	// Specifies the denominator. If the denominator specified is less than the numerator, the final
	// fractional percentage is capped at 1 (100%).
	Denominator FractionalPercent_DenominatorType `protobuf:"varint,2,opt,name=denominator,proto3,enum=istio.policy.v1beta1.FractionalPercent_DenominatorType" json:"denominator,omitempty"`
}

func (m *FractionalPercent) Reset()      { *m = FractionalPercent{} }
func (*FractionalPercent) ProtoMessage() {}
func (*FractionalPercent) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{9}
}
func (m *FractionalPercent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FractionalPercent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FractionalPercent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FractionalPercent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FractionalPercent.Merge(m, src)
}
func (m *FractionalPercent) XXX_Size() int {
	return m.Size()
}
func (m *FractionalPercent) XXX_DiscardUnknown() {
	xxx_messageInfo_FractionalPercent.DiscardUnknown(m)
}

var xxx_messageInfo_FractionalPercent proto.InternalMessageInfo

func (m *FractionalPercent) GetNumerator() uint32 {
	if m != nil {
		return m.Numerator
	}
	return 0
}

func (m *FractionalPercent) GetDenominator() FractionalPercent_DenominatorType {
	if m != nil {
		return m.Denominator
	}
	return HUNDRED
}

// Authentication allows the operator to specify the authentication of
// connections to out-of-process infrastructure backend.
type Authentication struct {
	// Types that are valid to be assigned to AuthType:
	//	*Authentication_Tls
	//	*Authentication_Mutual
	AuthType isAuthentication_AuthType `protobuf_oneof:"auth_type"`
}

func (m *Authentication) Reset()      { *m = Authentication{} }
func (*Authentication) ProtoMessage() {}
func (*Authentication) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{10}
}
func (m *Authentication) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Authentication) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Authentication.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Authentication) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Authentication.Merge(m, src)
}
func (m *Authentication) XXX_Size() int {
	return m.Size()
}
func (m *Authentication) XXX_DiscardUnknown() {
	xxx_messageInfo_Authentication.DiscardUnknown(m)
}

var xxx_messageInfo_Authentication proto.InternalMessageInfo

type isAuthentication_AuthType interface {
	isAuthentication_AuthType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Authentication_Tls struct {
	Tls *Tls `protobuf:"bytes,1,opt,name=tls,proto3,oneof"`
}
type Authentication_Mutual struct {
	Mutual *Mutual `protobuf:"bytes,2,opt,name=mutual,proto3,oneof"`
}

func (*Authentication_Tls) isAuthentication_AuthType()    {}
func (*Authentication_Mutual) isAuthentication_AuthType() {}

func (m *Authentication) GetAuthType() isAuthentication_AuthType {
	if m != nil {
		return m.AuthType
	}
	return nil
}

func (m *Authentication) GetTls() *Tls {
	if x, ok := m.GetAuthType().(*Authentication_Tls); ok {
		return x.Tls
	}
	return nil
}

func (m *Authentication) GetMutual() *Mutual {
	if x, ok := m.GetAuthType().(*Authentication_Mutual); ok {
		return x.Mutual
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Authentication) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Authentication_Tls)(nil),
		(*Authentication_Mutual)(nil),
	}
}

// Tls let operator specify client authentication setting when TLS is used for
// connection to the backend.
type Tls struct {
	// The path to the file holding additional CA certificates to well known
	// public certs.
	CaCertificates string `protobuf:"bytes,1,opt,name=ca_certificates,json=caCertificates,proto3" json:"ca_certificates,omitempty"`
	// Specifies how to get access token for client authn and authz.
	//
	// Types that are valid to be assigned to TokenSource:
	//	*Tls_TokenPath
	//	*Tls_Oauth
	TokenSource isTls_TokenSource `protobuf_oneof:"token_source"`
	// Specifies how to pass access token to the adapter backend.
	//
	// Types that are valid to be assigned to TokenType:
	//	*Tls_AuthHeader_
	//	*Tls_CustomHeader
	TokenType isTls_TokenType `protobuf_oneof:"token_type"`
	// Used to configure mixer TLS client to verify the hostname on the returned
	// certificates. It is also included in the client's handshake to support SNI.
	ServerName string `protobuf:"bytes,6,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
}

func (m *Tls) Reset()      { *m = Tls{} }
func (*Tls) ProtoMessage() {}
func (*Tls) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{11}
}
func (m *Tls) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tls) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tls.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tls) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tls.Merge(m, src)
}
func (m *Tls) XXX_Size() int {
	return m.Size()
}
func (m *Tls) XXX_DiscardUnknown() {
	xxx_messageInfo_Tls.DiscardUnknown(m)
}

var xxx_messageInfo_Tls proto.InternalMessageInfo

type isTls_TokenSource interface {
	isTls_TokenSource()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTls_TokenType interface {
	isTls_TokenType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Tls_TokenPath struct {
	TokenPath string `protobuf:"bytes,2,opt,name=token_path,json=tokenPath,proto3,oneof"`
}
type Tls_Oauth struct {
	Oauth *OAuth `protobuf:"bytes,3,opt,name=oauth,proto3,oneof"`
}
type Tls_AuthHeader_ struct {
	AuthHeader Tls_AuthHeader `protobuf:"varint,4,opt,name=auth_header,json=authHeader,proto3,enum=istio.policy.v1beta1.Tls_AuthHeader,oneof"`
}
type Tls_CustomHeader struct {
	CustomHeader string `protobuf:"bytes,5,opt,name=custom_header,json=customHeader,proto3,oneof"`
}

func (*Tls_TokenPath) isTls_TokenSource()  {}
func (*Tls_Oauth) isTls_TokenSource()      {}
func (*Tls_AuthHeader_) isTls_TokenType()  {}
func (*Tls_CustomHeader) isTls_TokenType() {}

func (m *Tls) GetTokenSource() isTls_TokenSource {
	if m != nil {
		return m.TokenSource
	}
	return nil
}
func (m *Tls) GetTokenType() isTls_TokenType {
	if m != nil {
		return m.TokenType
	}
	return nil
}

func (m *Tls) GetCaCertificates() string {
	if m != nil {
		return m.CaCertificates
	}
	return ""
}

func (m *Tls) GetTokenPath() string {
	if x, ok := m.GetTokenSource().(*Tls_TokenPath); ok {
		return x.TokenPath
	}
	return ""
}

func (m *Tls) GetOauth() *OAuth {
	if x, ok := m.GetTokenSource().(*Tls_Oauth); ok {
		return x.Oauth
	}
	return nil
}

func (m *Tls) GetAuthHeader() Tls_AuthHeader {
	if x, ok := m.GetTokenType().(*Tls_AuthHeader_); ok {
		return x.AuthHeader
	}
	return PLAIN
}

func (m *Tls) GetCustomHeader() string {
	if x, ok := m.GetTokenType().(*Tls_CustomHeader); ok {
		return x.CustomHeader
	}
	return ""
}

func (m *Tls) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Tls) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Tls_TokenPath)(nil),
		(*Tls_Oauth)(nil),
		(*Tls_AuthHeader_)(nil),
		(*Tls_CustomHeader)(nil),
	}
}

// OAuth let operator specify config to fetch access token via oauth when using
// TLS for connection to the backend.
type OAuth struct {
	// OAuth client id for mixer.
	ClientId string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// The path to the file holding the client secret for oauth.
	ClientSecret string `protobuf:"bytes,2,opt,name=client_secret,json=clientSecret,proto3" json:"client_secret,omitempty"`
	// The Resource server's token endpoint URL.
	TokenUrl string `protobuf:"bytes,3,opt,name=token_url,json=tokenUrl,proto3" json:"token_url,omitempty"`
	// List of requested permissions.
	Scopes []string `protobuf:"bytes,4,rep,name=scopes,proto3" json:"scopes,omitempty"`
	// Additional parameters for requests to the token endpoint.
	EndpointParams map[string]string `protobuf:"bytes,5,rep,name=endpoint_params,json=endpointParams,proto3" json:"endpoint_params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *OAuth) Reset()      { *m = OAuth{} }
func (*OAuth) ProtoMessage() {}
func (*OAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{12}
}
func (m *OAuth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OAuth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OAuth.Merge(m, src)
}
func (m *OAuth) XXX_Size() int {
	return m.Size()
}
func (m *OAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_OAuth.DiscardUnknown(m)
}

var xxx_messageInfo_OAuth proto.InternalMessageInfo

func (m *OAuth) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *OAuth) GetClientSecret() string {
	if m != nil {
		return m.ClientSecret
	}
	return ""
}

func (m *OAuth) GetTokenUrl() string {
	if m != nil {
		return m.TokenUrl
	}
	return ""
}

func (m *OAuth) GetScopes() []string {
	if m != nil {
		return m.Scopes
	}
	return nil
}

func (m *OAuth) GetEndpointParams() map[string]string {
	if m != nil {
		return m.EndpointParams
	}
	return nil
}

// Mutual let operator specify TLS configuration for Mixer as client if mutual TLS is used to
// secure connection to adapter backend.
type Mutual struct {
	// The path to the file holding the private key for mutual TLS. If omitted, the
	// default Mixer private key will be used.
	PrivateKey string `protobuf:"bytes,1,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// The path to the file holding client certificate for mutual TLS. If omitted, the
	// default Mixer certificates will be used.
	ClientCertificate string `protobuf:"bytes,2,opt,name=client_certificate,json=clientCertificate,proto3" json:"client_certificate,omitempty"`
	// The path to the file holding additional CA certificates that are needed to
	// verify the presented adapter certificates. By default Mixer should already
	// include Istio CA certificates and system certificates in cert pool.
	CaCertificates string `protobuf:"bytes,3,opt,name=ca_certificates,json=caCertificates,proto3" json:"ca_certificates,omitempty"`
	// Used to configure mixer mutual TLS client to supply server name for SNI.
	// It is not used to verify the hostname of the peer certificate, since
	// Istio verifies whitelisted SAN fields in mutual TLS.
	ServerName string `protobuf:"bytes,4,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
}

func (m *Mutual) Reset()      { *m = Mutual{} }
func (*Mutual) ProtoMessage() {}
func (*Mutual) Descriptor() ([]byte, []int) {
	return fileDescriptor_dfb7777e81b6b919, []int{13}
}
func (m *Mutual) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mutual) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mutual.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mutual) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mutual.Merge(m, src)
}
func (m *Mutual) XXX_Size() int {
	return m.Size()
}
func (m *Mutual) XXX_DiscardUnknown() {
	xxx_messageInfo_Mutual.DiscardUnknown(m)
}

var xxx_messageInfo_Mutual proto.InternalMessageInfo

func (m *Mutual) GetPrivateKey() string {
	if m != nil {
		return m.PrivateKey
	}
	return ""
}

func (m *Mutual) GetClientCertificate() string {
	if m != nil {
		return m.ClientCertificate
	}
	return ""
}

func (m *Mutual) GetCaCertificates() string {
	if m != nil {
		return m.CaCertificates
	}
	return ""
}

func (m *Mutual) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func init() {
	proto.RegisterEnum("istio.policy.v1beta1.Rule_HeaderOperationTemplate_Operation", Rule_HeaderOperationTemplate_Operation_name, Rule_HeaderOperationTemplate_Operation_value)
	proto.RegisterEnum("istio.policy.v1beta1.FractionalPercent_DenominatorType", FractionalPercent_DenominatorType_name, FractionalPercent_DenominatorType_value)
	proto.RegisterEnum("istio.policy.v1beta1.Tls_AuthHeader", Tls_AuthHeader_name, Tls_AuthHeader_value)
	proto.RegisterType((*AttributeManifest)(nil), "istio.policy.v1beta1.AttributeManifest")
	proto.RegisterMapType((map[string]*AttributeManifest_AttributeInfo)(nil), "istio.policy.v1beta1.AttributeManifest.AttributesEntry")
	proto.RegisterType((*AttributeManifest_AttributeInfo)(nil), "istio.policy.v1beta1.AttributeManifest.AttributeInfo")
	proto.RegisterType((*Rule)(nil), "istio.policy.v1beta1.Rule")
	proto.RegisterType((*Rule_HeaderOperationTemplate)(nil), "istio.policy.v1beta1.Rule.HeaderOperationTemplate")
	proto.RegisterType((*Action)(nil), "istio.policy.v1beta1.Action")
	proto.RegisterType((*Instance)(nil), "istio.policy.v1beta1.Instance")
	proto.RegisterMapType((map[string]string)(nil), "istio.policy.v1beta1.Instance.AttributeBindingsEntry")
	proto.RegisterType((*Handler)(nil), "istio.policy.v1beta1.Handler")
	proto.RegisterType((*Connection)(nil), "istio.policy.v1beta1.Connection")
	proto.RegisterType((*Sampling)(nil), "istio.policy.v1beta1.Sampling")
	proto.RegisterType((*RandomSampling)(nil), "istio.policy.v1beta1.RandomSampling")
	proto.RegisterType((*RateLimitSampling)(nil), "istio.policy.v1beta1.RateLimitSampling")
	proto.RegisterType((*FractionalPercent)(nil), "istio.policy.v1beta1.FractionalPercent")
	proto.RegisterType((*Authentication)(nil), "istio.policy.v1beta1.Authentication")
	proto.RegisterType((*Tls)(nil), "istio.policy.v1beta1.Tls")
	proto.RegisterType((*OAuth)(nil), "istio.policy.v1beta1.OAuth")
	proto.RegisterMapType((map[string]string)(nil), "istio.policy.v1beta1.OAuth.EndpointParamsEntry")
	proto.RegisterType((*Mutual)(nil), "istio.policy.v1beta1.Mutual")
}

func init() { proto.RegisterFile("policy/v1beta1/cfg.proto", fileDescriptor_dfb7777e81b6b919) }

var fileDescriptor_dfb7777e81b6b919 = []byte{
	// 1557 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xbf, 0x73, 0x1b, 0xc5,
	0x17, 0xd7, 0x49, 0x96, 0x2c, 0x3d, 0xd9, 0xb2, 0xbc, 0xf1, 0x37, 0x56, 0x94, 0x7c, 0x65, 0xa3,
	0xc0, 0x24, 0x4d, 0xa4, 0xd8, 0x81, 0x04, 0x32, 0x29, 0x90, 0x6c, 0x05, 0x79, 0xe2, 0xd8, 0x62,
	0x6d, 0x07, 0x48, 0xc1, 0xcd, 0xfa, 0x6e, 0x6d, 0xdf, 0xe4, 0x7e, 0x71, 0xb7, 0xa7, 0x89, 0x3b,
	0x0a, 0x7a, 0x52, 0x52, 0x53, 0x01, 0x0d, 0xff, 0x01, 0x75, 0x1a, 0x66, 0x32, 0xc3, 0x0c, 0xe3,
	0x0a, 0x12, 0xa5, 0xa1, 0x61, 0x26, 0x05, 0x7f, 0x00, 0x73, 0xbb, 0x7b, 0x77, 0xb2, 0x2c, 0x65,
	0x12, 0xba, 0xdb, 0xf7, 0x3e, 0xef, 0xf7, 0xdb, 0xf7, 0xf6, 0xa0, 0xe2, 0x3a, 0xa6, 0xa1, 0x1d,
	0x37, 0xfb, 0x2b, 0xfb, 0x94, 0x91, 0x95, 0xa6, 0x76, 0x70, 0xd8, 0x70, 0x3d, 0x87, 0x39, 0x68,
	0xc1, 0xf0, 0x99, 0xe1, 0x34, 0x04, 0xbf, 0x21, 0xf9, 0xd5, 0x85, 0x43, 0xe7, 0xd0, 0xe1, 0x80,
	0x66, 0xf8, 0x25, 0xb0, 0xd5, 0xa5, 0x43, 0xc7, 0x39, 0x34, 0x69, 0x93, 0xb8, 0x46, 0xf3, 0xc0,
	0xa0, 0xa6, 0xae, 0xee, 0xd3, 0x23, 0xd2, 0x37, 0x1c, 0x4f, 0x02, 0x2e, 0x49, 0x00, 0x3f, 0xed,
	0x07, 0x07, 0x4d, 0x9f, 0x79, 0x81, 0xc6, 0x24, 0xb7, 0x36, 0xca, 0xd5, 0x03, 0x8f, 0x30, 0xc3,
	0xb1, 0x23, 0xf5, 0x23, 0x4e, 0xf6, 0x89, 0x19, 0x50, 0x95, 0x1d, 0xbb, 0x54, 0x00, 0xea, 0xdf,
	0x66, 0x60, 0xbe, 0xc5, 0x98, 0x67, 0xec, 0x07, 0x8c, 0xde, 0x27, 0xb6, 0x71, 0x40, 0x7d, 0x86,
	0xaa, 0x90, 0xf7, 0x68, 0xdf, 0xf0, 0x0d, 0xc7, 0xae, 0x28, 0xcb, 0xca, 0xd5, 0x02, 0x8e, 0xcf,
	0x68, 0x11, 0xa6, 0x6c, 0x62, 0xd1, 0x4a, 0x3a, 0xa4, 0xb7, 0x33, 0xcf, 0x5b, 0x69, 0xcc, 0x09,
	0xe8, 0x33, 0x00, 0x12, 0x69, 0xf2, 0x2b, 0x99, 0xe5, 0xcc, 0xd5, 0xe2, 0xea, 0xad, 0xc6, 0xb8,
	0x5c, 0x34, 0xce, 0x58, 0x4c, 0x28, 0x7e, 0xc7, 0x66, 0xde, 0x31, 0x1e, 0x52, 0x55, 0xed, 0xc3,
	0x6c, 0xcc, 0xde, 0xb0, 0x0f, 0x1c, 0xb4, 0x0c, 0x45, 0x9d, 0xfa, 0x9a, 0x67, 0xb8, 0x2c, 0xf1,
	0x70, 0x98, 0x84, 0xd6, 0x00, 0x92, 0x50, 0xb9, 0xab, 0xa5, 0xd5, 0xa5, 0xf1, 0xbe, 0x3c, 0x08,
	0x71, 0xbb, 0xc7, 0x2e, 0x15, 0xb1, 0x14, 0xfa, 0xd1, 0xb9, 0xca, 0x60, 0x6e, 0xc4, 0x2d, 0x54,
	0x86, 0xcc, 0x23, 0x7a, 0x2c, 0x2d, 0x86, 0x9f, 0xe8, 0x1e, 0x64, 0xb9, 0x04, 0x37, 0x52, 0x5c,
	0xfd, 0xe0, 0xad, 0x03, 0x0e, 0x23, 0xc2, 0x42, 0xc7, 0xed, 0xf4, 0x87, 0x4a, 0xfd, 0xd7, 0x29,
	0x98, 0xc2, 0x81, 0x49, 0xd1, 0x02, 0x64, 0x2d, 0xc2, 0xb4, 0x23, 0x69, 0x4d, 0x1c, 0xd0, 0x4d,
	0x98, 0x26, 0x5a, 0x18, 0xa3, 0x5f, 0x49, 0xf3, 0x14, 0x5f, 0x9a, 0x60, 0x91, 0x83, 0x70, 0x04,
	0x46, 0x36, 0x5c, 0xf0, 0xe8, 0x57, 0x01, 0xf5, 0x99, 0x7a, 0x44, 0x89, 0x4e, 0x3d, 0xd5, 0x71,
	0xa9, 0xe8, 0x95, 0xa8, 0x58, 0xab, 0xe3, 0x35, 0x85, 0xce, 0x34, 0xba, 0x5c, 0x66, 0x3b, 0x12,
	0xd9, 0xa5, 0x96, 0x6b, 0x12, 0x46, 0xf1, 0xa2, 0x54, 0x3a, 0xc2, 0xf7, 0x91, 0x0b, 0x55, 0x8f,
	0xfa, 0xae, 0x63, 0xfb, 0x74, 0x8c, 0xc1, 0xa9, 0xff, 0x6c, 0xb0, 0x12, 0x69, 0x3d, 0x63, 0xf1,
	0x36, 0xe4, 0x7d, 0x62, 0xb9, 0xa6, 0x61, 0x1f, 0x56, 0xb2, 0xbc, 0x18, 0xb5, 0xf1, 0xfa, 0x77,
	0x24, 0x0a, 0xc7, 0xf8, 0xea, 0x89, 0x02, 0x8b, 0x13, 0x2c, 0xc6, 0x0d, 0xaf, 0x8c, 0x36, 0xfc,
	0x79, 0xc8, 0xf1, 0xb2, 0x89, 0x4a, 0x14, 0xb0, 0x3c, 0xa1, 0x87, 0x50, 0x88, 0x43, 0xad, 0x64,
	0x78, 0xef, 0xdd, 0x79, 0xfb, 0x48, 0x1b, 0x31, 0x05, 0x27, 0xea, 0xea, 0xd7, 0xa1, 0x10, 0xd3,
	0x51, 0x11, 0xa6, 0x71, 0xa7, 0xb7, 0xd9, 0x5a, 0xeb, 0x94, 0x53, 0x08, 0x20, 0x87, 0x3b, 0xf7,
	0xb7, 0x1f, 0x74, 0xca, 0x4a, 0xf8, 0xdd, 0xea, 0xf5, 0x3a, 0x5b, 0xeb, 0xe5, 0x74, 0xfd, 0x4b,
	0xc8, 0x89, 0x5e, 0x40, 0xff, 0x87, 0xe9, 0x23, 0x62, 0xeb, 0x26, 0xf5, 0x86, 0x2f, 0x6f, 0x44,
	0x43, 0xef, 0x40, 0xc1, 0xb0, 0x7d, 0x46, 0x6c, 0x4d, 0x5e, 0x5f, 0x09, 0x48, 0xa8, 0x08, 0xc9,
	0x54, 0x4c, 0xf1, 0x8e, 0xe4, 0xdf, 0xf5, 0xdf, 0xd3, 0x90, 0xdf, 0x90, 0x88, 0xc9, 0xb9, 0xba,
	0x01, 0xf3, 0x9a, 0x63, 0xb9, 0x86, 0x49, 0x75, 0x95, 0xc9, 0x08, 0x2b, 0xff, 0xfc, 0xfd, 0xe3,
	0x72, 0x02, 0x2c, 0x47, 0x80, 0x38, 0xf3, 0x55, 0xc8, 0xc7, 0xd8, 0xb4, 0x18, 0x43, 0xd1, 0x19,
	0xbd, 0x0f, 0x39, 0x97, 0x78, 0xc4, 0xf2, 0x79, 0x86, 0x8b, 0xab, 0x8b, 0x0d, 0x31, 0x0a, 0x1b,
	0xd1, 0x28, 0x6c, 0xec, 0xf0, 0x41, 0x29, 0x74, 0x4b, 0x2c, 0xd2, 0x01, 0xc5, 0x83, 0x45, 0xdd,
	0x37, 0x6c, 0xdd, 0xb0, 0x0f, 0xa3, 0x6e, 0x9c, 0x70, 0x75, 0xa3, 0xd8, 0x92, 0x1b, 0xdb, 0x96,
	0x72, 0x62, 0x52, 0xcd, 0x93, 0x51, 0x7a, 0x75, 0x1d, 0xce, 0x8f, 0x07, 0x8f, 0x99, 0x1f, 0x0b,
	0xc3, 0xf3, 0xa3, 0x30, 0x3c, 0x08, 0x06, 0x0a, 0x4c, 0x77, 0x65, 0x6d, 0x26, 0xe6, 0x75, 0x05,
	0xe2, 0xb4, 0xa9, 0x44, 0x27, 0x2e, 0xa3, 0xde, 0x48, 0x5a, 0xe7, 0x22, 0x7e, 0x4b, 0xb0, 0x51,
	0x05, 0xa6, 0x23, 0xa4, 0xb0, 0x19, 0x1d, 0x51, 0xf3, 0x0d, 0x73, 0x1a, 0xa7, 0xf3, 0x63, 0x00,
	0xcd, 0xb1, 0x6d, 0xca, 0xfb, 0x8b, 0x77, 0x45, 0x71, 0x75, 0x79, 0x7c, 0x1a, 0xd7, 0x62, 0x1c,
	0x1e, 0x92, 0xa9, 0xff, 0xac, 0x00, 0x24, 0x2c, 0xe1, 0x9b, 0xee, 0x51, 0xdf, 0x4f, 0x7c, 0xe3,
	0x47, 0xf4, 0x11, 0x4c, 0x33, 0xc3, 0xa2, 0x4e, 0xc0, 0xa4, 0x73, 0x17, 0xce, 0x38, 0xb7, 0x2e,
	0x77, 0x5f, 0x7b, 0xea, 0xbb, 0x3f, 0x97, 0x14, 0x1c, 0xe1, 0xd1, 0x26, 0x94, 0x48, 0xc0, 0x8e,
	0xa8, 0xcd, 0x0c, 0x8d, 0x0c, 0x79, 0xfa, 0xee, 0x84, 0xc9, 0x79, 0x0a, 0x8b, 0x47, 0x64, 0xeb,
	0x4f, 0x14, 0xc8, 0x47, 0x13, 0x04, 0xdd, 0x81, 0x9c, 0x47, 0x6c, 0xdd, 0xb1, 0x78, 0x65, 0x26,
	0xaa, 0xc4, 0x1c, 0x13, 0xcf, 0x1d, 0x29, 0x83, 0xee, 0x02, 0x78, 0x84, 0x51, 0xd5, 0x34, 0x2c,
	0x83, 0xc9, 0x05, 0x72, 0x65, 0x92, 0x06, 0x46, 0x37, 0x43, 0x58, 0xac, 0xa4, 0xe0, 0x45, 0xa4,
	0xfa, 0x6f, 0x0a, 0x94, 0x4e, 0x9b, 0x40, 0x2b, 0xb0, 0x90, 0x34, 0x3a, 0x7d, 0xec, 0x86, 0x39,
	0x4c, 0x76, 0xe5, 0xb9, 0x98, 0xd7, 0x89, 0x59, 0xa8, 0x07, 0x73, 0x2e, 0xf5, 0x34, 0x6a, 0x33,
	0x95, 0xcf, 0x45, 0xaa, 0xbf, 0xde, 0xa5, 0xbb, 0x9e, 0xd8, 0x2d, 0xc4, 0xec, 0x09, 0x31, 0x5c,
	0x92, 0xf2, 0x3b, 0x42, 0x1c, 0xdd, 0x81, 0x6a, 0xe0, 0x53, 0xd5, 0xb0, 0x75, 0xea, 0x52, 0x5b,
	0x0f, 0x35, 0x8b, 0xc8, 0xed, 0xb0, 0xc0, 0x61, 0x19, 0xf3, 0xb8, 0x12, 0xf8, 0x74, 0x23, 0x01,
	0xe0, 0x98, 0x5f, 0xff, 0x45, 0x81, 0xf9, 0x33, 0x61, 0xa3, 0x1e, 0xcc, 0x47, 0x53, 0x5b, 0x8d,
	0x1e, 0x3b, 0x32, 0xf9, 0xaf, 0xe9, 0x88, 0xfc, 0xd3, 0x3f, 0x96, 0x52, 0xbc, 0x2b, 0xca, 0x91,
	0x74, 0xc4, 0x43, 0xab, 0xf0, 0x3f, 0x8b, 0x3c, 0x56, 0x03, 0x5b, 0x46, 0xad, 0x52, 0x9b, 0x79,
	0x06, 0x15, 0x1d, 0x98, 0xc1, 0xe7, 0x2c, 0xf2, 0x78, 0x2f, 0xe2, 0x75, 0x04, 0x0b, 0x5d, 0x86,
	0xd9, 0xd8, 0x8b, 0xb0, 0x0e, 0x3c, 0x98, 0x0c, 0x9e, 0x89, 0x88, 0xa1, 0xdf, 0x3c, 0x80, 0x33,
	0x49, 0x42, 0x97, 0xa0, 0x60, 0x07, 0x56, 0x38, 0xc2, 0x1d, 0x8f, 0x3b, 0x3e, 0x8b, 0x13, 0x02,
	0xfa, 0x22, 0x7c, 0xda, 0xd8, 0x8e, 0x65, 0xd8, 0x9c, 0x2f, 0x5e, 0x2e, 0xb7, 0xde, 0xb0, 0x00,
	0x8d, 0xf5, 0x44, 0x34, 0x7c, 0xc1, 0xe0, 0x61, 0x5d, 0xf5, 0xeb, 0x30, 0x37, 0xc2, 0x0f, 0x17,
	0x48, 0x77, 0x6f, 0x6b, 0x1d, 0x77, 0xd6, 0xcb, 0x29, 0x54, 0x86, 0x99, 0xdd, 0xce, 0x96, 0xba,
	0xdb, 0xdd, 0xde, 0xdb, 0x69, 0x6d, 0xad, 0x97, 0x95, 0xfa, 0x37, 0x0a, 0x94, 0x4e, 0xdf, 0x06,
	0x74, 0x0d, 0x32, 0xcc, 0xf4, 0xe3, 0x84, 0x8f, 0xf5, 0x6b, 0xd7, 0xf4, 0xbb, 0x29, 0x1c, 0xe2,
	0xd0, 0x4d, 0xc8, 0x59, 0x01, 0x0b, 0x88, 0x29, 0x5b, 0x69, 0xc2, 0x63, 0xe5, 0x3e, 0xc7, 0x74,
	0x53, 0x58, 0xa2, 0xdb, 0x45, 0x28, 0x84, 0xd7, 0x8e, 0x3f, 0xdf, 0xea, 0x27, 0x69, 0xc8, 0xec,
	0x9a, 0x3e, 0xba, 0x02, 0x73, 0x1a, 0x51, 0x35, 0xea, 0x31, 0xe3, 0x20, 0xf4, 0x87, 0xfa, 0xb2,
	0x9d, 0x4b, 0x1a, 0x59, 0x1b, 0xa2, 0xa2, 0x25, 0x00, 0xe6, 0x3c, 0xa2, 0xb6, 0xea, 0x12, 0x76,
	0x24, 0x06, 0x49, 0x37, 0x85, 0x0b, 0x9c, 0xd6, 0x23, 0xec, 0x08, 0xdd, 0x80, 0xac, 0x13, 0xea,
	0x97, 0xa3, 0xe4, 0xe2, 0x78, 0xaf, 0xb6, 0xc3, 0xd8, 0xbb, 0x29, 0x2c, 0xb0, 0xe8, 0x13, 0x28,
	0x72, 0x9f, 0xc4, 0x6b, 0x86, 0xcf, 0x90, 0xd2, 0xa4, 0x0b, 0xbf, 0x6b, 0xfa, 0x7c, 0x8e, 0x88,
	0xdd, 0xde, 0x55, 0x30, 0x90, 0xf8, 0x84, 0xde, 0x83, 0x59, 0x2d, 0xf0, 0x99, 0x63, 0x45, 0xaa,
	0xb2, 0xdc, 0x43, 0x05, 0xcf, 0x08, 0xb2, 0x84, 0x2d, 0x41, 0xd1, 0xa7, 0x5e, 0x9f, 0x7a, 0x2a,
	0x1f, 0xfd, 0x39, 0x1e, 0x2a, 0x08, 0xd2, 0x56, 0xb8, 0x79, 0x2f, 0x03, 0x24, 0x36, 0x50, 0x01,
	0xb2, 0xbd, 0xcd, 0xd6, 0xc6, 0x96, 0x78, 0x0a, 0xb4, 0x3b, 0x2d, 0xdc, 0xc1, 0x65, 0xa5, 0x5d,
	0x82, 0x19, 0x91, 0x0b, 0xdf, 0x09, 0x3c, 0x8d, 0xb6, 0x67, 0xa2, 0xdc, 0xf0, 0xd4, 0xfe, 0x94,
	0x86, 0x2c, 0x0f, 0x13, 0x2d, 0x43, 0x41, 0x33, 0x8d, 0xf0, 0x8a, 0x1a, 0xfa, 0xf0, 0x9a, 0xc9,
	0x0b, 0xea, 0x86, 0x8e, 0xae, 0xc2, 0xac, 0x44, 0xf8, 0x54, 0xf3, 0x28, 0x1b, 0x7e, 0x44, 0xcc,
	0x08, 0xce, 0x0e, 0x67, 0x84, 0xba, 0x84, 0x8d, 0xc0, 0x33, 0x79, 0x8a, 0x23, 0x5d, 0x9c, 0xba,
	0xe7, 0x99, 0xe1, 0xd3, 0xc9, 0xd7, 0x1c, 0x97, 0x8a, 0xdd, 0x5b, 0xc0, 0xf2, 0x84, 0x3e, 0x87,
	0x39, 0x6a, 0xeb, 0xae, 0x63, 0xd8, 0x4c, 0x95, 0xab, 0x28, 0xcb, 0x97, 0x73, 0xf3, 0x35, 0x25,
	0x6a, 0x74, 0xa4, 0x48, 0x8f, 0x4b, 0x88, 0xb5, 0x5c, 0xa2, 0xa7, 0x88, 0xd5, 0x16, 0x9c, 0x1b,
	0x03, 0x7b, 0xab, 0x85, 0xfc, 0xbd, 0x02, 0x39, 0xd1, 0xa9, 0x61, 0x6d, 0x5c, 0xcf, 0xe8, 0x87,
	0xc3, 0x3b, 0x11, 0x07, 0x49, 0xba, 0x47, 0x8f, 0xd1, 0x35, 0x40, 0x32, 0x59, 0x43, 0xfd, 0x2a,
	0x55, 0xce, 0x0b, 0xce, 0x50, 0xcb, 0x8e, 0x6b, 0xed, 0xcc, 0x84, 0xd6, 0x3e, 0xd5, 0x14, 0x53,
	0xa3, 0x4d, 0xd1, 0xfe, 0xf4, 0xd9, 0x8b, 0x5a, 0xea, 0xe4, 0x45, 0x2d, 0xf5, 0xea, 0x45, 0x4d,
	0xf9, 0x7a, 0x50, 0x53, 0x7e, 0x18, 0xd4, 0x94, 0xa7, 0x83, 0x9a, 0xf2, 0x6c, 0x50, 0x53, 0x9e,
	0x0f, 0x6a, 0xca, 0x5f, 0x83, 0x5a, 0xea, 0xd5, 0xa0, 0xa6, 0x3c, 0x79, 0x59, 0x4b, 0x3d, 0x7b,
	0x59, 0x4b, 0x9d, 0xbc, 0xac, 0xa5, 0x1e, 0x5e, 0x14, 0xd9, 0x35, 0x1c, 0xfe, 0x23, 0x7a, 0xfa,
	0xa7, 0x71, 0x3f, 0xc7, 0xe7, 0xe9, 0x8d, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x8b, 0x0c, 0x72,
	0x92, 0xf2, 0x0e, 0x00, 0x00,
}

func (x Rule_HeaderOperationTemplate_Operation) String() string {
	s, ok := Rule_HeaderOperationTemplate_Operation_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x FractionalPercent_DenominatorType) String() string {
	s, ok := FractionalPercent_DenominatorType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Tls_AuthHeader) String() string {
	s, ok := Tls_AuthHeader_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *AttributeManifest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttributeManifest)
	if !ok {
		that2, ok := that.(AttributeManifest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Revision != that1.Revision {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return false
	}
	for i := range this.Attributes {
		if !this.Attributes[i].Equal(that1.Attributes[i]) {
			return false
		}
	}
	return true
}
func (this *AttributeManifest_AttributeInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttributeManifest_AttributeInfo)
	if !ok {
		that2, ok := that.(AttributeManifest_AttributeInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.ValueType != that1.ValueType {
		return false
	}
	return true
}
func (this *Rule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Rule)
	if !ok {
		that2, ok := that.(Rule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Match != that1.Match {
		return false
	}
	if len(this.Actions) != len(that1.Actions) {
		return false
	}
	for i := range this.Actions {
		if !this.Actions[i].Equal(that1.Actions[i]) {
			return false
		}
	}
	if len(this.RequestHeaderOperations) != len(that1.RequestHeaderOperations) {
		return false
	}
	for i := range this.RequestHeaderOperations {
		if !this.RequestHeaderOperations[i].Equal(that1.RequestHeaderOperations[i]) {
			return false
		}
	}
	if len(this.ResponseHeaderOperations) != len(that1.ResponseHeaderOperations) {
		return false
	}
	for i := range this.ResponseHeaderOperations {
		if !this.ResponseHeaderOperations[i].Equal(that1.ResponseHeaderOperations[i]) {
			return false
		}
	}
	if !this.Sampling.Equal(that1.Sampling) {
		return false
	}
	return true
}
func (this *Rule_HeaderOperationTemplate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Rule_HeaderOperationTemplate)
	if !ok {
		that2, ok := that.(Rule_HeaderOperationTemplate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	if this.Operation != that1.Operation {
		return false
	}
	return true
}
func (this *Action) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action)
	if !ok {
		that2, ok := that.(Action)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Handler != that1.Handler {
		return false
	}
	if len(this.Instances) != len(that1.Instances) {
		return false
	}
	for i := range this.Instances {
		if this.Instances[i] != that1.Instances[i] {
			return false
		}
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Instance) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Instance)
	if !ok {
		that2, ok := that.(Instance)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.CompiledTemplate != that1.CompiledTemplate {
		return false
	}
	if this.Template != that1.Template {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	if len(this.AttributeBindings) != len(that1.AttributeBindings) {
		return false
	}
	for i := range this.AttributeBindings {
		if this.AttributeBindings[i] != that1.AttributeBindings[i] {
			return false
		}
	}
	return true
}
func (this *Handler) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Handler)
	if !ok {
		that2, ok := that.(Handler)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.CompiledAdapter != that1.CompiledAdapter {
		return false
	}
	if this.Adapter != that1.Adapter {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	if !this.Connection.Equal(that1.Connection) {
		return false
	}
	return true
}
func (this *Connection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Connection)
	if !ok {
		that2, ok := that.(Connection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Timeout != nil && that1.Timeout != nil {
		if *this.Timeout != *that1.Timeout {
			return false
		}
	} else if this.Timeout != nil {
		return false
	} else if that1.Timeout != nil {
		return false
	}
	if !this.Authentication.Equal(that1.Authentication) {
		return false
	}
	return true
}
func (this *Sampling) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Sampling)
	if !ok {
		that2, ok := that.(Sampling)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Random.Equal(that1.Random) {
		return false
	}
	if !this.RateLimit.Equal(that1.RateLimit) {
		return false
	}
	return true
}
func (this *RandomSampling) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RandomSampling)
	if !ok {
		that2, ok := that.(RandomSampling)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AttributeExpression != that1.AttributeExpression {
		return false
	}
	if !this.PercentSampled.Equal(that1.PercentSampled) {
		return false
	}
	if this.UseIndependentRandomness != that1.UseIndependentRandomness {
		return false
	}
	return true
}
func (this *RateLimitSampling) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimitSampling)
	if !ok {
		that2, ok := that.(RateLimitSampling)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SamplingDuration != that1.SamplingDuration {
		return false
	}
	if this.MaxUnsampledEntries != that1.MaxUnsampledEntries {
		return false
	}
	if this.SamplingRate != that1.SamplingRate {
		return false
	}
	return true
}
func (this *FractionalPercent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FractionalPercent)
	if !ok {
		that2, ok := that.(FractionalPercent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Numerator != that1.Numerator {
		return false
	}
	if this.Denominator != that1.Denominator {
		return false
	}
	return true
}
func (this *Authentication) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Authentication)
	if !ok {
		that2, ok := that.(Authentication)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthType == nil {
		if this.AuthType != nil {
			return false
		}
	} else if this.AuthType == nil {
		return false
	} else if !this.AuthType.Equal(that1.AuthType) {
		return false
	}
	return true
}
func (this *Authentication_Tls) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Authentication_Tls)
	if !ok {
		that2, ok := that.(Authentication_Tls)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Tls.Equal(that1.Tls) {
		return false
	}
	return true
}
func (this *Authentication_Mutual) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Authentication_Mutual)
	if !ok {
		that2, ok := that.(Authentication_Mutual)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Mutual.Equal(that1.Mutual) {
		return false
	}
	return true
}
func (this *Tls) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tls)
	if !ok {
		that2, ok := that.(Tls)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CaCertificates != that1.CaCertificates {
		return false
	}
	if that1.TokenSource == nil {
		if this.TokenSource != nil {
			return false
		}
	} else if this.TokenSource == nil {
		return false
	} else if !this.TokenSource.Equal(that1.TokenSource) {
		return false
	}
	if that1.TokenType == nil {
		if this.TokenType != nil {
			return false
		}
	} else if this.TokenType == nil {
		return false
	} else if !this.TokenType.Equal(that1.TokenType) {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *Tls_TokenPath) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tls_TokenPath)
	if !ok {
		that2, ok := that.(Tls_TokenPath)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TokenPath != that1.TokenPath {
		return false
	}
	return true
}
func (this *Tls_Oauth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tls_Oauth)
	if !ok {
		that2, ok := that.(Tls_Oauth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Oauth.Equal(that1.Oauth) {
		return false
	}
	return true
}
func (this *Tls_AuthHeader_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tls_AuthHeader_)
	if !ok {
		that2, ok := that.(Tls_AuthHeader_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AuthHeader != that1.AuthHeader {
		return false
	}
	return true
}
func (this *Tls_CustomHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tls_CustomHeader)
	if !ok {
		that2, ok := that.(Tls_CustomHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CustomHeader != that1.CustomHeader {
		return false
	}
	return true
}
func (this *OAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OAuth)
	if !ok {
		that2, ok := that.(OAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientId != that1.ClientId {
		return false
	}
	if this.ClientSecret != that1.ClientSecret {
		return false
	}
	if this.TokenUrl != that1.TokenUrl {
		return false
	}
	if len(this.Scopes) != len(that1.Scopes) {
		return false
	}
	for i := range this.Scopes {
		if this.Scopes[i] != that1.Scopes[i] {
			return false
		}
	}
	if len(this.EndpointParams) != len(that1.EndpointParams) {
		return false
	}
	for i := range this.EndpointParams {
		if this.EndpointParams[i] != that1.EndpointParams[i] {
			return false
		}
	}
	return true
}
func (this *Mutual) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Mutual)
	if !ok {
		that2, ok := that.(Mutual)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PrivateKey != that1.PrivateKey {
		return false
	}
	if this.ClientCertificate != that1.ClientCertificate {
		return false
	}
	if this.CaCertificates != that1.CaCertificates {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *AttributeManifest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v1beta1.AttributeManifest{")
	s = append(s, "Revision: "+fmt.Sprintf("%#v", this.Revision)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]*AttributeManifest_AttributeInfo{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%#v: %#v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	if this.Attributes != nil {
		s = append(s, "Attributes: "+mapStringForAttributes+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AttributeManifest_AttributeInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1beta1.AttributeManifest_AttributeInfo{")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "ValueType: "+fmt.Sprintf("%#v", this.ValueType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Rule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&v1beta1.Rule{")
	s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	if this.Actions != nil {
		s = append(s, "Actions: "+fmt.Sprintf("%#v", this.Actions)+",\n")
	}
	if this.RequestHeaderOperations != nil {
		s = append(s, "RequestHeaderOperations: "+fmt.Sprintf("%#v", this.RequestHeaderOperations)+",\n")
	}
	if this.ResponseHeaderOperations != nil {
		s = append(s, "ResponseHeaderOperations: "+fmt.Sprintf("%#v", this.ResponseHeaderOperations)+",\n")
	}
	if this.Sampling != nil {
		s = append(s, "Sampling: "+fmt.Sprintf("%#v", this.Sampling)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Rule_HeaderOperationTemplate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v1beta1.Rule_HeaderOperationTemplate{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Values: "+fmt.Sprintf("%#v", this.Values)+",\n")
	s = append(s, "Operation: "+fmt.Sprintf("%#v", this.Operation)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Action) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v1beta1.Action{")
	s = append(s, "Handler: "+fmt.Sprintf("%#v", this.Handler)+",\n")
	s = append(s, "Instances: "+fmt.Sprintf("%#v", this.Instances)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Instance) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&v1beta1.Instance{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "CompiledTemplate: "+fmt.Sprintf("%#v", this.CompiledTemplate)+",\n")
	s = append(s, "Template: "+fmt.Sprintf("%#v", this.Template)+",\n")
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	keysForAttributeBindings := make([]string, 0, len(this.AttributeBindings))
	for k, _ := range this.AttributeBindings {
		keysForAttributeBindings = append(keysForAttributeBindings, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributeBindings)
	mapStringForAttributeBindings := "map[string]string{"
	for _, k := range keysForAttributeBindings {
		mapStringForAttributeBindings += fmt.Sprintf("%#v: %#v,", k, this.AttributeBindings[k])
	}
	mapStringForAttributeBindings += "}"
	if this.AttributeBindings != nil {
		s = append(s, "AttributeBindings: "+mapStringForAttributeBindings+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Handler) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&v1beta1.Handler{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "CompiledAdapter: "+fmt.Sprintf("%#v", this.CompiledAdapter)+",\n")
	s = append(s, "Adapter: "+fmt.Sprintf("%#v", this.Adapter)+",\n")
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	if this.Connection != nil {
		s = append(s, "Connection: "+fmt.Sprintf("%#v", this.Connection)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Connection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v1beta1.Connection{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	if this.Authentication != nil {
		s = append(s, "Authentication: "+fmt.Sprintf("%#v", this.Authentication)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Sampling) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1beta1.Sampling{")
	if this.Random != nil {
		s = append(s, "Random: "+fmt.Sprintf("%#v", this.Random)+",\n")
	}
	if this.RateLimit != nil {
		s = append(s, "RateLimit: "+fmt.Sprintf("%#v", this.RateLimit)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RandomSampling) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v1beta1.RandomSampling{")
	s = append(s, "AttributeExpression: "+fmt.Sprintf("%#v", this.AttributeExpression)+",\n")
	if this.PercentSampled != nil {
		s = append(s, "PercentSampled: "+fmt.Sprintf("%#v", this.PercentSampled)+",\n")
	}
	s = append(s, "UseIndependentRandomness: "+fmt.Sprintf("%#v", this.UseIndependentRandomness)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RateLimitSampling) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v1beta1.RateLimitSampling{")
	s = append(s, "SamplingDuration: "+fmt.Sprintf("%#v", this.SamplingDuration)+",\n")
	s = append(s, "MaxUnsampledEntries: "+fmt.Sprintf("%#v", this.MaxUnsampledEntries)+",\n")
	s = append(s, "SamplingRate: "+fmt.Sprintf("%#v", this.SamplingRate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FractionalPercent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1beta1.FractionalPercent{")
	s = append(s, "Numerator: "+fmt.Sprintf("%#v", this.Numerator)+",\n")
	s = append(s, "Denominator: "+fmt.Sprintf("%#v", this.Denominator)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Authentication) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1beta1.Authentication{")
	if this.AuthType != nil {
		s = append(s, "AuthType: "+fmt.Sprintf("%#v", this.AuthType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Authentication_Tls) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&v1beta1.Authentication_Tls{` +
		`Tls:` + fmt.Sprintf("%#v", this.Tls) + `}`}, ", ")
	return s
}
func (this *Authentication_Mutual) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&v1beta1.Authentication_Mutual{` +
		`Mutual:` + fmt.Sprintf("%#v", this.Mutual) + `}`}, ", ")
	return s
}
func (this *Tls) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&v1beta1.Tls{")
	s = append(s, "CaCertificates: "+fmt.Sprintf("%#v", this.CaCertificates)+",\n")
	if this.TokenSource != nil {
		s = append(s, "TokenSource: "+fmt.Sprintf("%#v", this.TokenSource)+",\n")
	}
	if this.TokenType != nil {
		s = append(s, "TokenType: "+fmt.Sprintf("%#v", this.TokenType)+",\n")
	}
	s = append(s, "ServerName: "+fmt.Sprintf("%#v", this.ServerName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Tls_TokenPath) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&v1beta1.Tls_TokenPath{` +
		`TokenPath:` + fmt.Sprintf("%#v", this.TokenPath) + `}`}, ", ")
	return s
}
func (this *Tls_Oauth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&v1beta1.Tls_Oauth{` +
		`Oauth:` + fmt.Sprintf("%#v", this.Oauth) + `}`}, ", ")
	return s
}
func (this *Tls_AuthHeader_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&v1beta1.Tls_AuthHeader_{` +
		`AuthHeader:` + fmt.Sprintf("%#v", this.AuthHeader) + `}`}, ", ")
	return s
}
func (this *Tls_CustomHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&v1beta1.Tls_CustomHeader{` +
		`CustomHeader:` + fmt.Sprintf("%#v", this.CustomHeader) + `}`}, ", ")
	return s
}
func (this *OAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&v1beta1.OAuth{")
	s = append(s, "ClientId: "+fmt.Sprintf("%#v", this.ClientId)+",\n")
	s = append(s, "ClientSecret: "+fmt.Sprintf("%#v", this.ClientSecret)+",\n")
	s = append(s, "TokenUrl: "+fmt.Sprintf("%#v", this.TokenUrl)+",\n")
	s = append(s, "Scopes: "+fmt.Sprintf("%#v", this.Scopes)+",\n")
	keysForEndpointParams := make([]string, 0, len(this.EndpointParams))
	for k, _ := range this.EndpointParams {
		keysForEndpointParams = append(keysForEndpointParams, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEndpointParams)
	mapStringForEndpointParams := "map[string]string{"
	for _, k := range keysForEndpointParams {
		mapStringForEndpointParams += fmt.Sprintf("%#v: %#v,", k, this.EndpointParams[k])
	}
	mapStringForEndpointParams += "}"
	if this.EndpointParams != nil {
		s = append(s, "EndpointParams: "+mapStringForEndpointParams+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Mutual) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&v1beta1.Mutual{")
	s = append(s, "PrivateKey: "+fmt.Sprintf("%#v", this.PrivateKey)+",\n")
	s = append(s, "ClientCertificate: "+fmt.Sprintf("%#v", this.ClientCertificate)+",\n")
	s = append(s, "CaCertificates: "+fmt.Sprintf("%#v", this.CaCertificates)+",\n")
	s = append(s, "ServerName: "+fmt.Sprintf("%#v", this.ServerName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCfg(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AttributeManifest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttributeManifest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttributeManifest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for k := range m.Attributes {
			v := m.Attributes[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCfg(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCfg(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCfg(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Revision) > 0 {
		i -= len(m.Revision)
		copy(dAtA[i:], m.Revision)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.Revision)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttributeManifest_AttributeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttributeManifest_AttributeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttributeManifest_AttributeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValueType != 0 {
		i = encodeVarintCfg(dAtA, i, uint64(m.ValueType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sampling != nil {
		{
			size, err := m.Sampling.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCfg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ResponseHeaderOperations) > 0 {
		for iNdEx := len(m.ResponseHeaderOperations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResponseHeaderOperations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCfg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RequestHeaderOperations) > 0 {
		for iNdEx := len(m.RequestHeaderOperations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequestHeaderOperations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCfg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Actions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCfg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Match) > 0 {
		i -= len(m.Match)
		copy(dAtA[i:], m.Match)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.Match)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Rule_HeaderOperationTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rule_HeaderOperationTemplate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rule_HeaderOperationTemplate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operation != 0 {
		i = encodeVarintCfg(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintCfg(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Instances) > 0 {
		for iNdEx := len(m.Instances) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Instances[iNdEx])
			copy(dAtA[i:], m.Instances[iNdEx])
			i = encodeVarintCfg(dAtA, i, uint64(len(m.Instances[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Handler) > 0 {
		i -= len(m.Handler)
		copy(dAtA[i:], m.Handler)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.Handler)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *Instance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Instance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Instance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CompiledTemplate) > 0 {
		i -= len(m.CompiledTemplate)
		copy(dAtA[i:], m.CompiledTemplate)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.CompiledTemplate)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
		i--
		dAtA[i] = 0xce
		i--
		dAtA[i] = 0xef
		i--
		dAtA[i] = 0xa2
	}
	if len(m.AttributeBindings) > 0 {
		for k := range m.AttributeBindings {
			v := m.AttributeBindings[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCfg(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCfg(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCfg(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCfg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Template) > 0 {
		i -= len(m.Template)
		copy(dAtA[i:], m.Template)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.Template)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Handler) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Handler) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Handler) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CompiledAdapter) > 0 {
		i -= len(m.CompiledAdapter)
		copy(dAtA[i:], m.CompiledAdapter)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.CompiledAdapter)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
		i--
		dAtA[i] = 0xce
		i--
		dAtA[i] = 0xef
		i--
		dAtA[i] = 0xa2
	}
	if m.Connection != nil {
		{
			size, err := m.Connection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCfg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCfg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Adapter) > 0 {
		i -= len(m.Adapter)
		copy(dAtA[i:], m.Adapter)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.Adapter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Connection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Connection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Authentication != nil {
		{
			size, err := m.Authentication.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCfg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Timeout != nil {
		n7, err7 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.Timeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Timeout):])
		if err7 != nil {
			return 0, err7
		}
		i -= n7
		i = encodeVarintCfg(dAtA, i, uint64(n7))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *Sampling) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sampling) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sampling) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RateLimit != nil {
		{
			size, err := m.RateLimit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCfg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Random != nil {
		{
			size, err := m.Random.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCfg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RandomSampling) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RandomSampling) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RandomSampling) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UseIndependentRandomness {
		i--
		if m.UseIndependentRandomness {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.PercentSampled != nil {
		{
			size, err := m.PercentSampled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCfg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.AttributeExpression) > 0 {
		i -= len(m.AttributeExpression)
		copy(dAtA[i:], m.AttributeExpression)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.AttributeExpression)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RateLimitSampling) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimitSampling) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitSampling) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SamplingRate != 0 {
		i = encodeVarintCfg(dAtA, i, uint64(m.SamplingRate))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxUnsampledEntries != 0 {
		i = encodeVarintCfg(dAtA, i, uint64(m.MaxUnsampledEntries))
		i--
		dAtA[i] = 0x10
	}
	n11, err11 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.SamplingDuration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.SamplingDuration):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintCfg(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FractionalPercent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FractionalPercent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FractionalPercent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Denominator != 0 {
		i = encodeVarintCfg(dAtA, i, uint64(m.Denominator))
		i--
		dAtA[i] = 0x10
	}
	if m.Numerator != 0 {
		i = encodeVarintCfg(dAtA, i, uint64(m.Numerator))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Authentication) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Authentication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Authentication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthType != nil {
		{
			size := m.AuthType.Size()
			i -= size
			if _, err := m.AuthType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Authentication_Tls) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Authentication_Tls) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tls != nil {
		{
			size, err := m.Tls.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCfg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Authentication_Mutual) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Authentication_Mutual) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Mutual != nil {
		{
			size, err := m.Mutual.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCfg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Tls) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tls) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tls) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServerName) > 0 {
		i -= len(m.ServerName)
		copy(dAtA[i:], m.ServerName)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.ServerName)))
		i--
		dAtA[i] = 0x32
	}
	if m.TokenType != nil {
		{
			size := m.TokenType.Size()
			i -= size
			if _, err := m.TokenType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TokenSource != nil {
		{
			size := m.TokenSource.Size()
			i -= size
			if _, err := m.TokenSource.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.CaCertificates) > 0 {
		i -= len(m.CaCertificates)
		copy(dAtA[i:], m.CaCertificates)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.CaCertificates)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tls_TokenPath) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Tls_TokenPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.TokenPath)
	copy(dAtA[i:], m.TokenPath)
	i = encodeVarintCfg(dAtA, i, uint64(len(m.TokenPath)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *Tls_Oauth) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Tls_Oauth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Oauth != nil {
		{
			size, err := m.Oauth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCfg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Tls_AuthHeader_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Tls_AuthHeader_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCfg(dAtA, i, uint64(m.AuthHeader))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *Tls_CustomHeader) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Tls_CustomHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.CustomHeader)
	copy(dAtA[i:], m.CustomHeader)
	i = encodeVarintCfg(dAtA, i, uint64(len(m.CustomHeader)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *OAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EndpointParams) > 0 {
		for k := range m.EndpointParams {
			v := m.EndpointParams[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCfg(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCfg(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCfg(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Scopes) > 0 {
		for iNdEx := len(m.Scopes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Scopes[iNdEx])
			copy(dAtA[i:], m.Scopes[iNdEx])
			i = encodeVarintCfg(dAtA, i, uint64(len(m.Scopes[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TokenUrl) > 0 {
		i -= len(m.TokenUrl)
		copy(dAtA[i:], m.TokenUrl)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.TokenUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClientSecret) > 0 {
		i -= len(m.ClientSecret)
		copy(dAtA[i:], m.ClientSecret)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.ClientSecret)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Mutual) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mutual) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mutual) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServerName) > 0 {
		i -= len(m.ServerName)
		copy(dAtA[i:], m.ServerName)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.ServerName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CaCertificates) > 0 {
		i -= len(m.CaCertificates)
		copy(dAtA[i:], m.CaCertificates)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.CaCertificates)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClientCertificate) > 0 {
		i -= len(m.ClientCertificate)
		copy(dAtA[i:], m.ClientCertificate)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.ClientCertificate)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PrivateKey) > 0 {
		i -= len(m.PrivateKey)
		copy(dAtA[i:], m.PrivateKey)
		i = encodeVarintCfg(dAtA, i, uint64(len(m.PrivateKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCfg(dAtA []byte, offset int, v uint64) int {
	offset -= sovCfg(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AttributeManifest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Revision)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCfg(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCfg(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCfg(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AttributeManifest_AttributeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	if m.ValueType != 0 {
		n += 1 + sovCfg(uint64(m.ValueType))
	}
	return n
}

func (m *Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Match)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovCfg(uint64(l))
		}
	}
	if len(m.RequestHeaderOperations) > 0 {
		for _, e := range m.RequestHeaderOperations {
			l = e.Size()
			n += 1 + l + sovCfg(uint64(l))
		}
	}
	if len(m.ResponseHeaderOperations) > 0 {
		for _, e := range m.ResponseHeaderOperations {
			l = e.Size()
			n += 1 + l + sovCfg(uint64(l))
		}
	}
	if m.Sampling != nil {
		l = m.Sampling.Size()
		n += 1 + l + sovCfg(uint64(l))
	}
	return n
}

func (m *Rule_HeaderOperationTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovCfg(uint64(l))
		}
	}
	if m.Operation != 0 {
		n += 1 + sovCfg(uint64(m.Operation))
	}
	return n
}

func (m *Action) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Handler)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	if len(m.Instances) > 0 {
		for _, s := range m.Instances {
			l = len(s)
			n += 1 + l + sovCfg(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	return n
}

func (m *Instance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	l = len(m.Template)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovCfg(uint64(l))
	}
	if len(m.AttributeBindings) > 0 {
		for k, v := range m.AttributeBindings {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCfg(uint64(len(k))) + 1 + len(v) + sovCfg(uint64(len(v)))
			n += mapEntrySize + 1 + sovCfg(uint64(mapEntrySize))
		}
	}
	l = len(m.CompiledTemplate)
	if l > 0 {
		n += 5 + l + sovCfg(uint64(l))
	}
	return n
}

func (m *Handler) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	l = len(m.Adapter)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovCfg(uint64(l))
	}
	if m.Connection != nil {
		l = m.Connection.Size()
		n += 1 + l + sovCfg(uint64(l))
	}
	l = len(m.CompiledAdapter)
	if l > 0 {
		n += 5 + l + sovCfg(uint64(l))
	}
	return n
}

func (m *Connection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	if m.Timeout != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Timeout)
		n += 1 + l + sovCfg(uint64(l))
	}
	if m.Authentication != nil {
		l = m.Authentication.Size()
		n += 1 + l + sovCfg(uint64(l))
	}
	return n
}

func (m *Sampling) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Random != nil {
		l = m.Random.Size()
		n += 1 + l + sovCfg(uint64(l))
	}
	if m.RateLimit != nil {
		l = m.RateLimit.Size()
		n += 1 + l + sovCfg(uint64(l))
	}
	return n
}

func (m *RandomSampling) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AttributeExpression)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	if m.PercentSampled != nil {
		l = m.PercentSampled.Size()
		n += 1 + l + sovCfg(uint64(l))
	}
	if m.UseIndependentRandomness {
		n += 2
	}
	return n
}

func (m *RateLimitSampling) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.SamplingDuration)
	n += 1 + l + sovCfg(uint64(l))
	if m.MaxUnsampledEntries != 0 {
		n += 1 + sovCfg(uint64(m.MaxUnsampledEntries))
	}
	if m.SamplingRate != 0 {
		n += 1 + sovCfg(uint64(m.SamplingRate))
	}
	return n
}

func (m *FractionalPercent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Numerator != 0 {
		n += 1 + sovCfg(uint64(m.Numerator))
	}
	if m.Denominator != 0 {
		n += 1 + sovCfg(uint64(m.Denominator))
	}
	return n
}

func (m *Authentication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthType != nil {
		n += m.AuthType.Size()
	}
	return n
}

func (m *Authentication_Tls) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tls != nil {
		l = m.Tls.Size()
		n += 1 + l + sovCfg(uint64(l))
	}
	return n
}
func (m *Authentication_Mutual) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mutual != nil {
		l = m.Mutual.Size()
		n += 1 + l + sovCfg(uint64(l))
	}
	return n
}
func (m *Tls) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CaCertificates)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	if m.TokenSource != nil {
		n += m.TokenSource.Size()
	}
	if m.TokenType != nil {
		n += m.TokenType.Size()
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	return n
}

func (m *Tls_TokenPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TokenPath)
	n += 1 + l + sovCfg(uint64(l))
	return n
}
func (m *Tls_Oauth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Oauth != nil {
		l = m.Oauth.Size()
		n += 1 + l + sovCfg(uint64(l))
	}
	return n
}
func (m *Tls_AuthHeader_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCfg(uint64(m.AuthHeader))
	return n
}
func (m *Tls_CustomHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CustomHeader)
	n += 1 + l + sovCfg(uint64(l))
	return n
}
func (m *OAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	l = len(m.ClientSecret)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	l = len(m.TokenUrl)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	if len(m.Scopes) > 0 {
		for _, s := range m.Scopes {
			l = len(s)
			n += 1 + l + sovCfg(uint64(l))
		}
	}
	if len(m.EndpointParams) > 0 {
		for k, v := range m.EndpointParams {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCfg(uint64(len(k))) + 1 + len(v) + sovCfg(uint64(len(v)))
			n += mapEntrySize + 1 + sovCfg(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Mutual) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrivateKey)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	l = len(m.ClientCertificate)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	l = len(m.CaCertificates)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovCfg(uint64(l))
	}
	return n
}

func sovCfg(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCfg(x uint64) (n int) {
	return sovCfg(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AttributeManifest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]*AttributeManifest_AttributeInfo{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%v: %v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	s := strings.Join([]string{`&AttributeManifest{`,
		`Revision:` + fmt.Sprintf("%v", this.Revision) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Attributes:` + mapStringForAttributes + `,`,
		`}`,
	}, "")
	return s
}
func (this *AttributeManifest_AttributeInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AttributeManifest_AttributeInfo{`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`ValueType:` + fmt.Sprintf("%v", this.ValueType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Rule) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForActions := "[]*Action{"
	for _, f := range this.Actions {
		repeatedStringForActions += strings.Replace(f.String(), "Action", "Action", 1) + ","
	}
	repeatedStringForActions += "}"
	repeatedStringForRequestHeaderOperations := "[]*Rule_HeaderOperationTemplate{"
	for _, f := range this.RequestHeaderOperations {
		repeatedStringForRequestHeaderOperations += strings.Replace(fmt.Sprintf("%v", f), "Rule_HeaderOperationTemplate", "Rule_HeaderOperationTemplate", 1) + ","
	}
	repeatedStringForRequestHeaderOperations += "}"
	repeatedStringForResponseHeaderOperations := "[]*Rule_HeaderOperationTemplate{"
	for _, f := range this.ResponseHeaderOperations {
		repeatedStringForResponseHeaderOperations += strings.Replace(fmt.Sprintf("%v", f), "Rule_HeaderOperationTemplate", "Rule_HeaderOperationTemplate", 1) + ","
	}
	repeatedStringForResponseHeaderOperations += "}"
	s := strings.Join([]string{`&Rule{`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`Actions:` + repeatedStringForActions + `,`,
		`RequestHeaderOperations:` + repeatedStringForRequestHeaderOperations + `,`,
		`ResponseHeaderOperations:` + repeatedStringForResponseHeaderOperations + `,`,
		`Sampling:` + strings.Replace(this.Sampling.String(), "Sampling", "Sampling", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Rule_HeaderOperationTemplate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Rule_HeaderOperationTemplate{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Values:` + fmt.Sprintf("%v", this.Values) + `,`,
		`Operation:` + fmt.Sprintf("%v", this.Operation) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Action) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Action{`,
		`Handler:` + fmt.Sprintf("%v", this.Handler) + `,`,
		`Instances:` + fmt.Sprintf("%v", this.Instances) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Instance) String() string {
	if this == nil {
		return "nil"
	}
	keysForAttributeBindings := make([]string, 0, len(this.AttributeBindings))
	for k, _ := range this.AttributeBindings {
		keysForAttributeBindings = append(keysForAttributeBindings, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributeBindings)
	mapStringForAttributeBindings := "map[string]string{"
	for _, k := range keysForAttributeBindings {
		mapStringForAttributeBindings += fmt.Sprintf("%v: %v,", k, this.AttributeBindings[k])
	}
	mapStringForAttributeBindings += "}"
	s := strings.Join([]string{`&Instance{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Template:` + fmt.Sprintf("%v", this.Template) + `,`,
		`Params:` + strings.Replace(fmt.Sprintf("%v", this.Params), "Struct", "types.Struct", 1) + `,`,
		`AttributeBindings:` + mapStringForAttributeBindings + `,`,
		`CompiledTemplate:` + fmt.Sprintf("%v", this.CompiledTemplate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Handler) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Handler{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Adapter:` + fmt.Sprintf("%v", this.Adapter) + `,`,
		`Params:` + strings.Replace(fmt.Sprintf("%v", this.Params), "Struct", "types.Struct", 1) + `,`,
		`Connection:` + strings.Replace(this.Connection.String(), "Connection", "Connection", 1) + `,`,
		`CompiledAdapter:` + fmt.Sprintf("%v", this.CompiledAdapter) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Connection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Connection{`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Timeout:` + strings.Replace(fmt.Sprintf("%v", this.Timeout), "Duration", "types.Duration", 1) + `,`,
		`Authentication:` + strings.Replace(this.Authentication.String(), "Authentication", "Authentication", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Sampling) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Sampling{`,
		`Random:` + strings.Replace(this.Random.String(), "RandomSampling", "RandomSampling", 1) + `,`,
		`RateLimit:` + strings.Replace(this.RateLimit.String(), "RateLimitSampling", "RateLimitSampling", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RandomSampling) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RandomSampling{`,
		`AttributeExpression:` + fmt.Sprintf("%v", this.AttributeExpression) + `,`,
		`PercentSampled:` + strings.Replace(this.PercentSampled.String(), "FractionalPercent", "FractionalPercent", 1) + `,`,
		`UseIndependentRandomness:` + fmt.Sprintf("%v", this.UseIndependentRandomness) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RateLimitSampling) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RateLimitSampling{`,
		`SamplingDuration:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.SamplingDuration), "Duration", "types.Duration", 1), `&`, ``, 1) + `,`,
		`MaxUnsampledEntries:` + fmt.Sprintf("%v", this.MaxUnsampledEntries) + `,`,
		`SamplingRate:` + fmt.Sprintf("%v", this.SamplingRate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FractionalPercent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FractionalPercent{`,
		`Numerator:` + fmt.Sprintf("%v", this.Numerator) + `,`,
		`Denominator:` + fmt.Sprintf("%v", this.Denominator) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Authentication) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Authentication{`,
		`AuthType:` + fmt.Sprintf("%v", this.AuthType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Authentication_Tls) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Authentication_Tls{`,
		`Tls:` + strings.Replace(fmt.Sprintf("%v", this.Tls), "Tls", "Tls", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Authentication_Mutual) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Authentication_Mutual{`,
		`Mutual:` + strings.Replace(fmt.Sprintf("%v", this.Mutual), "Mutual", "Mutual", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Tls) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Tls{`,
		`CaCertificates:` + fmt.Sprintf("%v", this.CaCertificates) + `,`,
		`TokenSource:` + fmt.Sprintf("%v", this.TokenSource) + `,`,
		`TokenType:` + fmt.Sprintf("%v", this.TokenType) + `,`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Tls_TokenPath) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Tls_TokenPath{`,
		`TokenPath:` + fmt.Sprintf("%v", this.TokenPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Tls_Oauth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Tls_Oauth{`,
		`Oauth:` + strings.Replace(fmt.Sprintf("%v", this.Oauth), "OAuth", "OAuth", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Tls_AuthHeader_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Tls_AuthHeader_{`,
		`AuthHeader:` + fmt.Sprintf("%v", this.AuthHeader) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Tls_CustomHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Tls_CustomHeader{`,
		`CustomHeader:` + fmt.Sprintf("%v", this.CustomHeader) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OAuth) String() string {
	if this == nil {
		return "nil"
	}
	keysForEndpointParams := make([]string, 0, len(this.EndpointParams))
	for k, _ := range this.EndpointParams {
		keysForEndpointParams = append(keysForEndpointParams, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEndpointParams)
	mapStringForEndpointParams := "map[string]string{"
	for _, k := range keysForEndpointParams {
		mapStringForEndpointParams += fmt.Sprintf("%v: %v,", k, this.EndpointParams[k])
	}
	mapStringForEndpointParams += "}"
	s := strings.Join([]string{`&OAuth{`,
		`ClientId:` + fmt.Sprintf("%v", this.ClientId) + `,`,
		`ClientSecret:` + fmt.Sprintf("%v", this.ClientSecret) + `,`,
		`TokenUrl:` + fmt.Sprintf("%v", this.TokenUrl) + `,`,
		`Scopes:` + fmt.Sprintf("%v", this.Scopes) + `,`,
		`EndpointParams:` + mapStringForEndpointParams + `,`,
		`}`,
	}, "")
	return s
}
func (this *Mutual) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Mutual{`,
		`PrivateKey:` + fmt.Sprintf("%v", this.PrivateKey) + `,`,
		`ClientCertificate:` + fmt.Sprintf("%v", this.ClientCertificate) + `,`,
		`CaCertificates:` + fmt.Sprintf("%v", this.CaCertificates) + `,`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCfg(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AttributeManifest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttributeManifest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttributeManifest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[string]*AttributeManifest_AttributeInfo)
			}
			var mapkey string
			var mapvalue *AttributeManifest_AttributeInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCfg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCfg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCfg
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCfg
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCfg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCfg
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCfg
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AttributeManifest_AttributeInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCfg(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCfg
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttributeManifest_AttributeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttributeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttributeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueType", wireType)
			}
			m.ValueType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValueType |= ValueType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCfg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeaderOperations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeaderOperations = append(m.RequestHeaderOperations, &Rule_HeaderOperationTemplate{})
			if err := m.RequestHeaderOperations[len(m.RequestHeaderOperations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeaderOperations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeaderOperations = append(m.ResponseHeaderOperations, &Rule_HeaderOperationTemplate{})
			if err := m.ResponseHeaderOperations[len(m.ResponseHeaderOperations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sampling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sampling == nil {
				m.Sampling = &Sampling{}
			}
			if err := m.Sampling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rule_HeaderOperationTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderOperationTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderOperationTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= Rule_HeaderOperationTemplate_Operation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCfg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handler", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Handler = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instances = append(m.Instances, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Instance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Instance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Instance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Template = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &types.Struct{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeBindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttributeBindings == nil {
				m.AttributeBindings = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCfg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCfg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCfg
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCfg
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCfg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCfg
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCfg
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCfg(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCfg
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AttributeBindings[mapkey] = mapvalue
			iNdEx = postIndex
		case 67794676:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompiledTemplate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompiledTemplate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Handler) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Handler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Handler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adapter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Adapter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &types.Struct{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connection == nil {
				m.Connection = &Connection{}
			}
			if err := m.Connection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 67794676:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompiledAdapter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompiledAdapter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeout == nil {
				m.Timeout = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.Timeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authentication", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Authentication == nil {
				m.Authentication = &Authentication{}
			}
			if err := m.Authentication.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sampling) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sampling: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sampling: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Random", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Random == nil {
				m.Random = &RandomSampling{}
			}
			if err := m.Random.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RateLimit == nil {
				m.RateLimit = &RateLimitSampling{}
			}
			if err := m.RateLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RandomSampling) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RandomSampling: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RandomSampling: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributeExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentSampled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PercentSampled == nil {
				m.PercentSampled = &FractionalPercent{}
			}
			if err := m.PercentSampled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseIndependentRandomness", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseIndependentRandomness = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCfg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimitSampling) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimitSampling: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimitSampling: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamplingDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.SamplingDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUnsampledEntries", wireType)
			}
			m.MaxUnsampledEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUnsampledEntries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamplingRate", wireType)
			}
			m.SamplingRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SamplingRate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCfg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FractionalPercent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FractionalPercent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FractionalPercent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Numerator", wireType)
			}
			m.Numerator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Numerator |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denominator", wireType)
			}
			m.Denominator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Denominator |= FractionalPercent_DenominatorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCfg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Authentication) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Authentication: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Authentication: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Tls{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthType = &Authentication_Tls{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutual", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Mutual{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthType = &Authentication_Mutual{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tls) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tls: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tls: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCertificates", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaCertificates = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenSource = &Tls_TokenPath{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oauth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OAuth{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TokenSource = &Tls_Oauth{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthHeader", wireType)
			}
			var v Tls_AuthHeader
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Tls_AuthHeader(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TokenType = &Tls_AuthHeader_{v}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomHeader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenType = &Tls_CustomHeader{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSecret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientSecret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scopes = append(m.Scopes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointParams == nil {
				m.EndpointParams = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCfg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCfg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCfg
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCfg
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCfg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCfg
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCfg
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCfg(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCfg
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EndpointParams[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mutual) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mutual: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mutual: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCertificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientCertificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCertificates", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaCertificates = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCfg(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCfg
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCfg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCfg
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCfg
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCfg
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCfg(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCfg
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCfg = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCfg   = fmt.Errorf("proto: integer overflow")
)
